<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Ott: Tool Support for
Semantics 
User Guide 
 version 0.25

</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:0px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -fix top2 -->
<!--CUT DEF section 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">Ott: Tool Support for
Semantics<BR>
User Guide<BR>
 version 0.25
</H1><H3 CLASS="titlerest">Peter Sewell<SUP>*</SUP> &#XA0;&#XA0;&#XA0;&#XA0;Francesco Zappa Nardelli<SUP>**</SUP><BR>
with Scott Owens<SUP>*</SUP>, Gilles Peskine<SUP>*</SUP>, Tom
Ridge<SUP>*</SUP>,<BR>
Susmit Sarkar<SUP>*</SUP>, and Rok Strni&#X161;a<SUP>*</SUP><BR>
 <SUP>*</SUP>University of Cambridge &#XA0;&#XA0;&#XA0;&#XA0;<SUP>**</SUP>INRIA</H3></TD></TR>
</TABLE><!--TOC section Contents-->
<H2 CLASS="section"><!--SEC ANCHOR -->Contents</H2><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc2">2&#XA0;&#XA0;Getting started with Ott</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc3">2.1&#XA0;&#XA0;Directory contents</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">2.2&#XA0;&#XA0;To build</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">2.3&#XA0;&#XA0;To run</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">2.4&#XA0;&#XA0;Emacs mode</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">2.5&#XA0;&#XA0;Copyright information</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">3&#XA0;&#XA0;A minimal Ott source file: the untyped CBV lambda calculus</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc9">3.1&#XA0;&#XA0;Index variables</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">4&#XA0;&#XA0;Generating LaTeX</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc11">4.1&#XA0;&#XA0;Specifying LaTeX for productions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">4.2&#XA0;&#XA0;Specifying LaTeX for grammar rules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">4.3&#XA0;&#XA0;Using the LaTeX code</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">5&#XA0;&#XA0;Generating proof assistant definitions</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc15">5.1&#XA0;&#XA0;Proof assistant code for grammar rules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">5.2&#XA0;&#XA0;Proof assistant code for inductive definitions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">5.3&#XA0;&#XA0;Representation of binding</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">5.4&#XA0;&#XA0;Helper functions for free variable and substitution functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">5.5&#XA0;&#XA0;Correctness of the generated proof assistant code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">5.6&#XA0;&#XA0;Using the generated proof assistant code</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc21">5.6.1&#XA0;&#XA0;Coq</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">5.6.2&#XA0;&#XA0;HOL</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">5.6.3&#XA0;&#XA0;Isabelle</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">6&#XA0;&#XA0;Judgments and formulae</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc25">6.1&#XA0;&#XA0;Naming of premises for the Coq backend</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">6.2&#XA0;&#XA0;In-line embedded prover code in premises</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">6.3&#XA0;&#XA0;User syntax</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">7&#XA0;&#XA0;Concrete terms and OCaml generation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">8&#XA0;&#XA0;Filtering: Using Ott syntax within LaTeX, Coq, Isabelle,
HOL, or OCaml</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc30">8.1&#XA0;&#XA0;Filtering embedded code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">8.2&#XA0;&#XA0;Filtering files</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">9&#XA0;&#XA0;Binding specifications</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">10&#XA0;&#XA0;Generating substitution and free variable functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">11&#XA0;&#XA0;Locally-nameless representation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">12&#XA0;&#XA0;List forms</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc36">12.1&#XA0;&#XA0;List dot forms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">12.2&#XA0;&#XA0;List comprehension forms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">12.3&#XA0;&#XA0;Proof assistant code for list forms</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc39">12.3.1&#XA0;&#XA0;Types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">12.3.2&#XA0;&#XA0;Terms (in inductive definition rules)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">12.3.3&#XA0;&#XA0;List forms in homomorphisms</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">13&#XA0;&#XA0;Subrules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">14&#XA0;&#XA0;Context rules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">15&#XA0;&#XA0;Auxiliary Rules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">16&#XA0;&#XA0;Functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">17&#XA0;&#XA0;Parsing Priorities</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">18&#XA0;&#XA0;Combining multiple source files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">19&#XA0;&#XA0;Hom blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc49">20&#XA0;&#XA0;Isabelle syntax support</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">21&#XA0;&#XA0;Isabelle code generation example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">22&#XA0;&#XA0;Reference: Command-line usage</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc52">23&#XA0;&#XA0;Reference: The language of symbolic terms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">24&#XA0;&#XA0;Reference: Generation of proof assistant definitions</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc54">24.1&#XA0;&#XA0;Generation of types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">24.2&#XA0;&#XA0;Generation of functions</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc56">24.2.1&#XA0;&#XA0;Subrule predicates</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">24.2.2&#XA0;&#XA0;Binding auxiliaries</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">24.2.3&#XA0;&#XA0;Free variables</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">24.2.4&#XA0;&#XA0;Substitutions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">24.3&#XA0;&#XA0;Generation of relations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">25&#XA0;&#XA0;Reference: Summary of homomorphisms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">26&#XA0;&#XA0;Reference: The Ott source grammar</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">27&#XA0;&#XA0;Reference: Examples</A>
</LI></UL><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>&#XA0;&#XA0;Introduction</H2><!--SEC END --><P><A NAME="a1"></A>Ott is a tool for writing definitions of programming languages and
calculi. 
It takes as input a definition of a language syntax and semantics, in
a concise and readable ASCII notation that is close to what one would
write in informal mathematics. It generates output:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
a LaTeX source file that defines commands to build a typeset version of
the definition;
</LI><LI CLASS="li-enumerate">a Coq version of the definition; 
</LI><LI CLASS="li-enumerate">a HOL version of the definition;
</LI><LI CLASS="li-enumerate">an Isabelle/HOL version of the definition; 
</LI><LI CLASS="li-enumerate">an OCaml version of the syntax of the definition.
</LI></OL><P>
Additionally, it can be run as a filter, taking a
LaTeX/Coq/Isabelle/HOL/OCaml source file
with embedded (symbolic) terms of the defined language, parsing them and replacing
them by typeset terms.</P><P>This document is a user guide for the tool. The papers
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="http://www.cl.cam.ac.uk/&#XA0;pes20/ott/ott-jfp.pdf">Ott: Effective Tool Support for the Working Semanticist</A>. Peter Sewell, Francesco Zappa Nardelli, Scott Owens, Gilles
Peskine, Thomas Ridge, Susmit Sarkar, Rok Strni&#X161;a. 
Journal of Functional Programming 20(1):71-122, 2010 [<A HREF="#ott-jfp">SZNO+10</A>].</LI><LI CLASS="li-itemize"><A HREF="http://www.cl.cam.ac.uk/&#XA0;pes20/ott/paper.pdf">Ott: Effective Tool Support for the Working Semanticist</A>. Peter Sewell, Francesco Zappa Nardelli, Scott Owens, Gilles
Peskine, Thomas Ridge, Susmit Sarkar, Rok Strni&#X161;a. 
ICFP&#X2019;07 [<A HREF="#ott-sub">SZNO+07</A>].</LI></UL><P>
gives an overview of the project, including discussion of motivation,
design decisions, and related work, and one should look at that together
with this manual. The project web page
</P><BLOCKQUOTE CLASS="quotation">
<A HREF="http://www.cl.cam.ac.uk/users/pes20/ott/"><TT>http://www.cl.cam.ac.uk/users/pes20/ott/</TT></A>
</BLOCKQUOTE><P>
includes source and binary distributions of the tool, under a
BSD-style licence. It also has a range of examples, including
untyped and simply typed CBV lambda calculus, ML polymorphism, various
first-order systems from Pierce&#X2019;s TAPL&#XA0;[<A HREF="#Pierce:TypeSystems">Pie02</A>], the
POPLmark F<SUB>&lt;:</SUB> language&#XA0;[<A HREF="#poplmark">ABF+05</A>], a module system by
Leroy&#XA0;[<A HREF="#Leroy-generativity">Ler96</A>, &#XA7;4] (extended with a term language and an
operational semantics), the LJ Java fragment and LJAM Java module
system&#XA0;[<A HREF="#ljam-sub">SSP07</A>], and a substantial fragment of OCaml.</P><P>Our main goal is to support work on large programming language
definitions, where the scale makes it hard to keep a definition
internally consistent, and hard to keep a tight correspondence between a
definition and implementations.
We also wish to ease rapid prototyping work with smaller calculi,
and to make it easier to exchange definitions and definition fragments
between groups.
Most simply, the tool can be used to aid completely informal LaTeX mathematics.
Here it permits the definition, and terms within proofs and
exposition, to be written in a clear, editable, ASCII notation, without LaTeX
noise. It generates good-quality typeset output. 
By parsing (and so sort-checking) this input, it quickly catches a
range of simple errors, e.g.&#XA0;inconsistent use of judgement forms or
metavariable naming conventions. 
That same input, extended with some additional data, can be used to generate formal definitions for
Coq, HOL, and Isabelle. It should thereby enable a smooth transition
between use of informal and formal mathematics. Further, the
tool can automatically generate definitions of functions for free
variables, single and multiple substitutions, subgrammar checks
(e.g.&#XA0;for value subgrammars), and binding auxiliary functions.
Ott supports a &#X2018;fully concrete&#X2019; representation, sufficient
for many examples but not dealing with general alpha equivalence. 
An experimental Coq backend generates definitions in locally-nameless style for a subset of the Ott metalanguage.
The OCaml backend 
generates type definitions that may be useful for developing a complete
implementation of the language, together with the functions listed
above. It does not generate anything for inductively defined relations
(the various proof-assistant code extraction facilities can
sometimes be used for that).
Our focus here is on the problem of writing and editing language
definitions, not (directly) on aiding mechanized proof of metatheory. If one
is involved in hard proofs about a relatively stable small calculus
then it will aid only a small part of the work (and one might choose
instead to work just within a single proof assistant), but for larger
languages the definition is a more substantial problem &#X2014; so much so
that only a handful of full-scale languages have been given complete definitions. We
aim to make this more commonplace, less of a heroic task.</P><!--TOC section Getting started with Ott-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>&#XA0;&#XA0;Getting started with Ott</H2><!--SEC END --><!--TOC subsection Directory contents-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">2.1</A>&#XA0;&#XA0;Directory contents</H3><!--SEC END --><P>

The source distribution contains:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>doc/</TT></TD><TD ALIGN=left NOWRAP>the user guide, in html, pdf, and ps</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>emacs/</TT></TD><TD ALIGN=left NOWRAP>an Ott Emacs mode</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>tex/</TT></TD><TD ALIGN=left NOWRAP>auxiliary files for LaTeX</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>coq/</TT></TD><TD ALIGN=left NOWRAP>auxiliary files for Coq</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>hol/</TT></TD><TD ALIGN=left NOWRAP>auxiliary files for HOL</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>tests/</TT></TD><TD ALIGN=left NOWRAP>various small example Ott files</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>examples/</TT></TD><TD ALIGN=left NOWRAP>some larger example Ott files</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>src/</TT></TD><TD ALIGN=left NOWRAP>the (OCaml) Ott sources</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>bin/</TT></TD><TD ALIGN=left NOWRAP>the Ott binary (binary distro only)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>Makefile</TT></TD><TD ALIGN=left NOWRAP>a Makefile for the examples</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>LICENCE</TT></TD><TD ALIGN=left NOWRAP>the BSD-style licence terms</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>README</TT></TD><TD ALIGN=left NOWRAP>this file (Section 2 of the user guide)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>revision_history.txt</TT></TD><TD ALIGN=left NOWRAP>the revision history</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>ocamlgraph-0.99a.tar.gz</TT></TD><TD ALIGN=left NOWRAP>a copy of the <TT>ocamlgraph</TT> library</TD></TR>
</TABLE><P>(we no longer provide a Windows binary distribution)
</P><!--TOC subsection To build-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc4">2.2</A>&#XA0;&#XA0;To build</H3><!--SEC END --><P>

Ott depends on OCaml version 3.09.1 or later. It builds with OCaml
3.12.1. (Ott cannot be
compiled with OCaml 3.08, and it also touched an OCaml bug in 3.10.0 for amd64,
fixed in 3.10.1).</P><P>The command
</P><PRE>
  make world
</PRE><P>
builds the <TT>ott</TT> binary in the <TT>bin/</TT> subdirectory. </P><P>This will compiles Ott using <TT>ocamlopt</TT>. To force it to
compile with <TT>ocamlc</TT> (which may give significantly slower execution
of Ott), do "<TT>make world.byt</TT>".</P><!--TOC subsection To run-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc5">2.3</A>&#XA0;&#XA0;To run</H3><!--SEC END --><P>

Ott runs as a command-line tool. Executing <TT>bin/ott</TT> shows the
usage and options. To run Ott on the test file
<TT>tests/test10.ott</TT>, generating LaTeX in <TT>test10.tex</TT> and
Coq in <TT>test10.v</TT>, type:
</P><PRE>
  bin/ott -i tests/test10.ott -o test10.tex -o test10.v
</PRE><P>
Isabelle and HOL can be generated with options <TT>-o test10.thy</TT> and
<TT>-o test10Script.sml</TT> respectively.</P><P>The Makefile has various sample targets, "<TT>make tests/test10.out</TT>",
"<TT>make test7</TT>", etc. Typically they generate:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP> <TT>out.tex</TT></TD><TD ALIGN=left NOWRAP>LaTeX source for a definition</TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>out.ps</TT></TD><TD ALIGN=left NOWRAP>the postscript built from that</TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>out.v</TT></TD><TD ALIGN=left NOWRAP>Coq source</TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>outScript.sml</TT></TD><TD ALIGN=left NOWRAP>HOL source</TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>out.thy</TT></TD><TD ALIGN=left NOWRAP>Isabelle source</TD></TR>
</TABLE><P>from files <TT>test10.ott</TT>, <TT>test8.ott</TT>, etc., in <TT>tests/</TT>.</P><!--TOC subsection Emacs mode-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc6">2.4</A>&#XA0;&#XA0;Emacs mode</H3><!--SEC END --><P>

The file <TT>emacs/ottmode.el</TT> defines a very simple Emacs mode for syntax
highlighting of Ott source files. It can be used by, for example,
adding the following to your <TT>.emacs</TT>, replacing <TT>PATH</TT> by a path to your
Ott <TT>emacs</TT> directory.
</P><PRE>
(setq load-path (cons (expand-file-name "PATH") load-path))
(require &#X2019;ottmode)
</PRE><!--TOC subsection Copyright information-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">2.5</A>&#XA0;&#XA0;Copyright information</H3><!--SEC END --><P>

The <TT>ocamlgraph</TT> library is distributed under the LGPL (from
<A HREF="http://www.lri.fr/~filliatr/ftp/ocamlgraph/"><TT>http://www.lri.fr/~filliatr/ftp/ocamlgraph/</TT></A>); we include a snapshot
for convenience. For its authorship and copyright information see the
files therein.</P><P>All other files are distributed under the BSD-style licence in <TT>LICENCE</TT>.</P><!--TOC section A minimal Ott source file: the untyped CBV lambda calculus-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">3</A>&#XA0;&#XA0;A minimal Ott source file: the untyped CBV lambda calculus</H2><!--SEC END --><P><A NAME="a51"></A>Fig.&#XA0;<A HREF="#a45">1</A> shows an Ott source file for an untyped call-by-value
(CBV) lambda calculus. This section explains the basic features that
appear there, while in the following sections we show what must be
added to generate typeset output, proof assistant definitions, and
other things.
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="minipage"><SPAN CLASS="textboxed">
</SPAN><PRE><SPAN CLASS="textboxed">
% minimal
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>metavar</TT></FONT></SPAN><SPAN CLASS="textboxed"> termvar</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>,</TT></FONT></SPAN><SPAN CLASS="textboxed"> x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">  

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>grammar</TT></FONT></SPAN><SPAN CLASS="textboxed">
t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;t_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">              
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> x            </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Var
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed"> x . t      </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> t t&#X2019;         </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> App 
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> ( t )        </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>S</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Paren
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed"> t / x </SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed"> t&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>M</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Tsub  

v </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;v_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">              
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed"> x . t      </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam 

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>subrules</TT></FONT></SPAN><SPAN CLASS="textboxed">
  v </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>&lt;::</TT></FONT></SPAN><SPAN CLASS="textboxed"> t

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defns</TT></FONT></SPAN><SPAN CLASS="textboxed">
Jop </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X201D; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">

 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defn</TT></FONT></SPAN><SPAN CLASS="textboxed">
 t1 &#X2013;&gt; t2 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">reduce</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">&#X201D;  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>by</TT></FONT></SPAN><SPAN CLASS="textboxed">


</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------------------</TT></FONT></SPAN><SPAN CLASS="textboxed">  :: ax_app
    (</SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">x.t12) v2 &#X2013;&gt;  </SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed">v2/x</SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed">t12

    t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: ctx_app_fun
    t1 t &#X2013;&gt; t1&#X2019; t

    t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: ctx_app_arg
    v t1 &#X2013;&gt; v t1&#X2019;
</SPAN></PRE><SPAN CLASS="textboxed">

</SPAN></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 1: Source: <TT>test10.0.ott</TT><A NAME="a45"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>
The figure is colourised, with Ott keywords like <FONT COLOR="#A51815"><TT>this</TT></FONT> and Ott
symbols such as <FONT COLOR="#007FFF"><TT>|</TT></FONT> and <FONT COLOR="#007FFF"><TT>::</TT></FONT>. Other user-specific input
appears like <TT>this</TT>.</P><P>At the top of the figure, the <FONT COLOR="#A51815"><TT>metavar</TT></FONT> declaration introduces
a sort of <EM>metavariables</EM> <TT>termvar</TT> (with synonym <TT>x</TT>), for term
variables.
The following <FONT COLOR="#A51815"><TT>grammar</TT></FONT> introduces two grammar rules, one for terms, with
<EM>nonterminal root</EM>
<TT>t</TT>, and one for values <TT>v</TT>.
This specifies the concrete syntax of object-language terms,
the abstract syntax representations for proof-assistant mathematics,
and the syntax of symbolic terms to be used in semantic rules.</P><P>Each rule has a rule name prefix (e.g.&#XA0;<TT>&#X2019;t_&#X2019;</TT>) and then a list
of productions. Each production, e.g.
</P><PRE>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT> x . t      <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam
</PRE><P>
specifies a syntactic form as a list of elements, here &#X2018;<CODE>\</CODE>&#X2019;,
&#X2018;<CODE>x</CODE>&#X2019;, &#X2018;<CODE>.</CODE>&#X2019;, and &#X2018;<CODE>t</CODE>&#X2019;, each of which is either a
metavariable (the &#X2018;<CODE>x</CODE>&#X2019;), a nonterminal (the &#X2018;<CODE>t</CODE>&#X2019;), or a
terminal 
(<TT>\</TT> <TT>.</TT> <TT>(</TT> <TT>)</TT> <TT>{</TT> <TT>}</TT> <TT>/</TT> <TT>--&gt;</TT>). 
Within productions all elements must be whitespace-separated, so that
the tool can deduce which are terminals. In the symbolic terms in
the semantic rules below, however, whitespace is required only where necessary.
A few terminals have to be quoted (with <CODE>''</CODE>) if they appear in a grammar, e.g. to
use <TT>|</TT> as an object-language token, as they are part of the Ott syntax, but they
do not have to be quoted at usage points. 
(If one accidentally omits inter-token whitespace in the grammar, the
output of Ott can be surprising. This is best diagnosed by looking at
the colourised ASCII or LaTeX output from Ott.)</P><P>Metavariables and nonterminals can be formed from the specified
metavariable and nonterminal roots by appending a suffix, e.g.&#XA0;the
nonterminal <CODE>t'</CODE> in the <CODE>App</CODE> and <CODE>Tsub</CODE> productions. </P><P>Between the <FONT COLOR="#007FFF"><TT>::</TT></FONT>&#X2019;s is an optional meta flag <FONT COLOR="#A51815"><TT>M</TT></FONT> or <FONT COLOR="#A51815"><TT>S</TT></FONT>. Non-meta
productions give rise to clauses of datatype definitions in the
Isabelle/Coq/HOL output, whereas meta productions do not. Later, we
will see how the user can specify how meta syntax should be translated
away when generating proof assistant output. The two flags <FONT COLOR="#A51815"><TT>M</TT></FONT>
and <FONT COLOR="#A51815"><TT>S</TT></FONT> are identical except that productions with the latter are 
admitted when parsing example concrete terms; the <FONT COLOR="#A51815"><TT>S</TT></FONT> tag is thus
appropriate for lightweight syntactic sugar, such as productions for
parentheses.</P><P>Each production has a production name (e.g.&#XA0;<CODE>t_Lam</CODE>), composed of
the rule name prefix (here&#XA0;<CODE>t_</CODE>) and the production name kernel
that follows the <FONT COLOR="#007FFF"><TT>::</TT></FONT>&#X2019;s (here&#XA0;<CODE>Lam</CODE>). The production name is
used as a constructor name in the generated Isabelle/Coq/HOL. </P><P>The tool supports arbitrary context-free grammars, extended with
special constructs for list forms (c.f.&#XA0;&#XA7;<A HREF="#a61">12</A>). </P><P>Following the <FONT COLOR="#A51815"><TT>grammar</TT></FONT> in this example is a <FONT COLOR="#A51815"><TT>subrule</TT></FONT>
declaration
</P><PRE>
  <FONT COLOR="#A51815"><TT>subrules</TT></FONT>
    v <FONT COLOR="#007FFF"><TT>&lt;::</TT></FONT> t
</PRE><P>
declaring that the <CODE>v</CODE> grammar rule (of values) is a
subgrammar of the <CODE>t</CODE> rule (of terms). The tool checks that
there is in fact a subgrammar relationship, i.e.&#XA0;that for each
production of the lower rule there exists a production of the higher
rule with corresponding elements (up to the subrule relation). 
The subrule declaration means that, in the semantic rules below, we
will be able to use <CODE>v</CODE>&#X2019;s in places where the grammar specifies <CODE>t</CODE>&#X2019;s.
In the generated Isabelle/Coq/HOL for this example only one free
datatype will be generated, for the <CODE>t</CODE> rule, while for the <CODE>v</CODE>
rule we generate an <CODE>is_v</CODE> predicate over the <CODE>t</CODE> type. Usages of
<CODE>v</CODE> nonterminals in the semantic rules will have instances of this
predicate automatically inserted.</P><P>Finally, we give a collection of definitions of inductive relations.
In this example there is just one family of definitions (of
operational judgements), introduced by the <FONT COLOR="#A51815"><TT>defns</TT></FONT> <CODE>Jop</CODE>; it contains just one
definition of a relation, called <CODE>reduce</CODE>. 
In general there may be many <FONT COLOR="#A51815"><TT>defns</TT></FONT> blocks, each of which introduces a
mutually recursive collection of <FONT COLOR="#A51815"><TT>defn</TT></FONT>s. 
The relation definition
<FONT COLOR="#A51815"><TT>defn</TT></FONT><CODE> ...</CODE>
also includes a grammar production specifying how elements of the
relation can be written and typeset, here
</P><PRE CLASS="verbatim">  t1 --&gt; t2
</PRE><P>As in the main grammar, the tokens of this syntax definition in the
header must be space-separated, but usages of the syntax generally
need not be.
Syntax rules for each family of
judgements, and for their union, are implicitly generated. 
The relation definition is given by a sequence of inference rules,
each with a horizontal line separating a number of premises from a
conclusion, for example as below.
</P><PRE>
    t1 &#X2013;&gt; t1&#X2019;
<FONT COLOR="#007FFF"><TT>    -------------- ::</TT></FONT> ctx_app_arg
    v t1 &#X2013;&gt; v t1&#X2019;
</PRE><P>
The conclusion must be a symbolic term of the form of the judgement being
defined.
In simple cases (as here) the premises can be symbolic terms of the
form of any of the defined judgements. More generally (see
&#XA7;<A HREF="#a53">6</A>) they can be symbolic terms of a user-defined
<FONT COLOR="#A51815"><TT>formula</TT></FONT> grammar, or in-line embedded prover code. 
Each rule
has a name, composed of a definition family prefix
(here empty), a definition prefix (here also empty) and a kernel
(the&#XA0;<CODE>ctx_app_arg</CODE>). 
</P><P>The symbolic terms in semantic rules are parsed with a scannerless parser, built
using parser combinators over character-list inputs. The parser
searches for all parses of the input. If none are found, the ASCII
and TeX output are annotated <TT>no parses</TT>, with a copy of the
input with <TT>***</TT> inserted at the point where the last token was
read. This is often at the point of the error (though if, for
example, a putative dot form is read but the two element lists cannot
be anti-unified, it will be after the point of the error). 
If multiple parses are found, the TeX output is annotated
<TT>multiple parses</TT> and the different parses are output to the
console in detail during the Ott run. 
If the option <TT>picky_multiple_parses</TT> is set to
<TT>true</TT>, multiple parses are always reported. If it set to
<TT>false</TT>, a symbolic term is considered ambiguous only if two
different parses compile to different strings (for a target).
The parser combinators use memoization and continuation-passing to
achieve reasonable performance on the small symbolic terms that are
typical in semantic rules. Their performance on large (whole-program
size) examples is untested.
To resolve ambiguity one can add metaproductions for parentheses (as
in Fig.&#XA0;<A HREF="#a45">1</A>), or 
production-name annotations in particular symbolic terms,
e.g.&#XA0;the <CODE>:t_tsub:</CODE> in the <CODE>AppAbs</CODE> rule of the POPLmark
example, 
<TT>test7.ott</TT>. There is currently no support for precedence
or associativity.</P><P>This file is included in the distribution as
<TT>tests/test10.0.ott</TT>. It can be processed by executing
</P><PRE>
   bin/ott -i tests/test10.0.ott
</PRE><P>
from the main directory. This simply reads in the file, checking that
it is well-formed. Adding options:
</P><PRE>
   bin/ott -show_sort true -show_defns true -i tests/test10.0.ott
</PRE><P>
it echos a colourised version to the screen,
with metavariables in red, nonterminals
in yellow, terminals in green, and object variables in white. 
The colourisation uses vt220 control codes; if they do not work on
your screen add <TT>-colour false</TT> to the middle of the command
line. To suppress the echo of the definition, add
<TT>-show_post_sort false</TT> and <TT>-show_defns false</TT>.</P><!--TOC subsection Index variables-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc9">3.1</A>&#XA0;&#XA0;Index variables</H3><!--SEC END --><P>
In addition to the <FONT COLOR="#A51815"><TT>metavar</TT></FONT> declarations above, the user can declare any number of distinguished <EM>index</EM>
metavariables, e.g. by:
</P><PRE>
  <FONT COLOR="#A51815"><TT>indexvar</TT></FONT> index<FONT COLOR="#007FFF"><TT>,</TT></FONT> i<FONT COLOR="#007FFF"><TT>,</TT></FONT> j<FONT COLOR="#007FFF"><TT>,</TT></FONT> n<FONT COLOR="#007FFF"><TT>,</TT></FONT> m <FONT COLOR="#007FFF"><TT>::=</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> num <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq</TT></FONT> nat <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>hol</TT></FONT> num <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
</PRE><P>
Given such a declaration, <CODE>index</CODE>, <CODE>i</CODE>, <CODE>j</CODE>, <CODE>n</CODE>
and <CODE>m</CODE> can be used in suffixes, e.g.&#XA0;in the production
</P><PRE>
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  ( t1 , <FONT COLOR="#007FFF"><TT>....</TT></FONT> , tn )           <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Tuple
</PRE><P>
There is a fixed ad-hoc language of suffixes, including numbers, primes, and index variables (see &#XA7;<A HREF="#a17">23</A>).
Index metavariables cannot themselves be suffixed.</P><!--TOC section Generating LaTeX-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">4</A>&#XA0;&#XA0;Generating LaTeX</H2><!--SEC END --><P><A NAME="a58"></A>The example from the previous section can already be used to generate
LaTeX, for example by executing 
</P><PRE>
   bin/ott -i tests/test10.0.ott -o out.tex 
</PRE><P>
to produce a LaTeX file <TT>out.tex</TT>. One often needs to
fine-tune the default typesetting, as illustrated in 
Figure&#XA0;<A HREF="#a46">2</A> (the Ott source) and Figure&#XA0;<A HREF="#a49">3</A>
(the resulting LaTeX). 
(The latter was built using the additional option <CODE>-tex_show_meta false</CODE>, to 
suppress display of the metaproductions.)
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="minipage"><SPAN CLASS="textboxed">
</SPAN><PRE><SPAN CLASS="textboxed">
% minimal + latex + comments
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>metavar</TT></FONT></SPAN><SPAN CLASS="textboxed"> termvar</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>,</TT></FONT></SPAN><SPAN CLASS="textboxed"> x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">   
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>tex</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">mathit</SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">termvar</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>grammar</TT></FONT></SPAN><SPAN CLASS="textboxed">
t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;t_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">                               </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> term    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> x            </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Var                   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> variable</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed"> x . t      </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam                   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> lambda  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> t t&#X2019;         </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> App                   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> app     </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> ( t )        </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>S</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Paren      
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed"> t / x </SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed"> t&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>M</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Tsub  

v </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;v_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">                               </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> value   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed"> x . t      </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam                   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> lambda  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>terminals</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;terminals_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">            </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> lambda  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>tex</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">lambda </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2013;&gt;          </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> red     </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>tex</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">longrightarrow </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>subrules</TT></FONT></SPAN><SPAN CLASS="textboxed">
  v </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>&lt;::</TT></FONT></SPAN><SPAN CLASS="textboxed"> t

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defns</TT></FONT></SPAN><SPAN CLASS="textboxed">
Jop </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X201D; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">

 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defn</TT></FONT></SPAN><SPAN CLASS="textboxed">
 t1 &#X2013;&gt; t2 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">reduce</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">&#X201D; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t1</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> reduces to </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t2</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>by</TT></FONT></SPAN><SPAN CLASS="textboxed">


</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------------------</TT></FONT></SPAN><SPAN CLASS="textboxed">  :: ax_app
    (</SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">x.t12) v2 &#X2013;&gt;  </SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed">v2/x</SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed">t12

    t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: ctx_app_fun
    t1 t &#X2013;&gt; t1&#X2019; t

    t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: ctx_app_arg
    v t1 &#X2013;&gt; v t1&#X2019;
</SPAN></PRE><SPAN CLASS="textboxed">

</SPAN></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2: Source: <TT>test10.2.ott</TT><A NAME="a46"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<IMG SRC="top2001.gif"><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3: Generated LaTeX: <TT>test10.2.tex</TT><A NAME="a49"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>
The source file has three additions to the previous file. 
Firstly, the <FONT COLOR="#A51815"><TT>metavar</TT></FONT> declaration is annotated with a
specification of how metavariables should be translated to LaTeX:
</P><PRE>
  <FONT COLOR="#A51815"><TT>metavar</TT></FONT> termvar<FONT COLOR="#007FFF"><TT>,</TT></FONT> x <FONT COLOR="#007FFF"><TT>::=</TT></FONT>   
    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>mathit<TT>{</TT><FONT COLOR="#007FFF"><TT>[[</TT></FONT>termvar<FONT COLOR="#007FFF"><TT>]]</TT></FONT><TT>}</TT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
Inside the <TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">tex</FONT></TT><TT> </TT>&#X2026;<TT> </TT><TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>
is some LaTeX code
<TT>\</TT><TT>mathit</TT><TT>{</TT><TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>termvar</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT><TT>}</TT> 
giving the translation of a <TT>termvar</TT> or <TT>x</TT>. Here they
are typeset in math italic (which in fact is also the default).
Within the translation, the metavariable itself can be mentioned
inside double square brackets <TT><FONT COLOR="#007FFF">[[</FONT></TT><TT> </TT>&#X2026;<TT> </TT><TT><FONT COLOR="#007FFF">]]</FONT></TT>.</P><P>Secondly, there is a grammar for a distinguished nonterminal root
<FONT COLOR="#A51815"><TT>terminals</TT></FONT>, with a 
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">tex</FONT></TT><TT> </TT>&#X2026;<TT> </TT><TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>
translation for each, overriding the default typesetting of some
terminals. Note that the other terminals 
(<TT>.</TT> <TT>(</TT> <TT>)</TT> <TT>{</TT> <TT>}</TT> <TT>/</TT>)
are still given their default typesetting.
</P><PRE>
  <FONT COLOR="#A51815"><TT>terminals</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;terminals_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT>            <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> lambda  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>lambda <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> &#X2013;&gt;          <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> red     <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>longrightarrow <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
Thirdly, the file has <FONT COLOR="#A51815"><TT>com</TT></FONT> comments, including
the 
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">com</FONT></TT><TT> term </TT><TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>
attached to a grammar rule, 
the 
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">com</FONT></TT><TT> variable</TT><TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>
attached to a production, and the
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">com</FONT></TT><TT> </TT><TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>t1</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT><TT> reduces to </TT><TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>t2</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>
attached to a semantic relation. These appear in the LaTeX output
as shown in Figure&#XA0;<A HREF="#a49">3</A>.</P><!--TOC subsection Specifying LaTeX for productions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">4.1</A>&#XA0;&#XA0;Specifying LaTeX for productions</H3><!--SEC END --><P>
One can also specify <FONT COLOR="#A51815"><TT>tex</TT></FONT> translations for productions, overriding the default
LaTeX typesetting, e.g.&#XA0;as in this example of
a type abstraction production.
</P><PRE>
    <FONT COLOR="#007FFF"><TT>|</TT></FONT>  X &lt;: T . t   <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> TLam   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>Lambda <FONT COLOR="#007FFF"><TT>[[</TT></FONT>X<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>&lt;:<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>T<FONT COLOR="#007FFF"><TT>]]</TT></FONT>. <TT>\</TT>, <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
These <EM>homomorphisms</EM>, or <EM>homs</EM><SUP><A NAME="text1" HREF="#note1">1</A></SUP>, can refer to the metavariables and
nonterminals that occur in the production, e.g.&#XA0;the <TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>X</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT>,
<TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>T</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT>, and <TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>t</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT> in the <FONT COLOR="#A51815"><TT>tex</TT></FONT> hom above,
interleaved with arbitrary strings and with typeset elements of the
<FONT COLOR="#A51815"><TT>terminals</TT></FONT> grammar, e.g.&#XA0;the <TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>&lt;:</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT>.</P><P>Homomorphisms are applied recursively down the structure of symbolic
terms. For example, an F<SUB>&lt;:</SUB> term
</P><PRE CLASS="verbatim">  (\X&lt;:T11.t12) [T2]
</PRE><P>would be LaTeX-pretty-printed, using the <FONT COLOR="#A51815"><TT>tex</TT></FONT> clause above, as
</P><PRE CLASS="verbatim">( \, \Lambda  \mathit{X} &lt;: \mathit{T_{\mathrm{11}}} . \, \mathit{t_{\mathrm{12}}} \, )
 \, \, [ \, \mathit{T_{\mathrm{2}}} \, ]
</PRE><P>which is typeset as below.
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<IMG SRC="top2002.gif"></TD></TR>
</TABLE><P>
Note the <CODE>X</CODE>, <CODE>T11</CODE> and <CODE>t12</CODE> of the symbolic term are
used to instantiate the formal parameters <CODE>X</CODE>, <CODE>T</CODE> and
<CODE>t</CODE> of the homomorphism definition clause. 
If the <CODE>t</CODE> itself had compound term structure, e.g. as below
</P><PRE CLASS="verbatim">  (\X&lt;:T. \X'&lt;:T'.x)
</PRE><P>the homomorphism would be applied recursively, producing 
</P><PRE CLASS="verbatim">( \, \Lambda  \mathit{X} &lt;: \mathit{T} . \,  \Lambda  \mathit{X'} &lt;: \mathit{T'} 
. \,  \mathit{x} \,  \, )
</PRE><P>typeset as follows.
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<IMG SRC="top2003.gif"></TD></TR>
</TABLE><P>
Where there is no user-supplied homomorphism clause the LaTeX
pretty-printing defaults to a sequence of the individual items
separated by thin spaces (<CODE>\,</CODE>),
with reasonable default fonts and making use of the <CODE>terminals</CODE> grammar where appropriate.</P><!--TOC subsection Specifying LaTeX for grammar rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc12">4.2</A>&#XA0;&#XA0;Specifying LaTeX for grammar rules</H3><!--SEC END --><P>
Grammar rules can include a <FONT COLOR="#A51815"><TT>tex</TT></FONT> hom specifying how all the
nonterminal roots should be typeset, e.g.
</P><PRE>
  type<FONT COLOR="#007FFF"><TT>,</TT></FONT> t<FONT COLOR="#007FFF"><TT>,</TT></FONT> s <FONT COLOR="#007FFF"><TT>::</TT></FONT> Typ_ <FONT COLOR="#007FFF"><TT>::=</TT></FONT>  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>mathsf<TT>{</TT><FONT COLOR="#007FFF"><TT>[[</TT></FONT>type<FONT COLOR="#007FFF"><TT>]]</TT></FONT><TT>}</TT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
        <FONT COLOR="#007FFF"><TT>|</TT></FONT> unit                  <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> unit   
        <FONT COLOR="#007FFF"><TT>|</TT></FONT> type * type&#X2019;          <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> pair   
        <FONT COLOR="#007FFF"><TT>|</TT></FONT> type -&gt; type&#X2019;         <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> fun    
</PRE><P>Alternatively, the individual nonterminal roots can have <FONT COLOR="#A51815"><TT>tex</TT></FONT>
homs specifying how they should be typeset:
</P><PRE>
  G <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>Gamma <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>,</TT></FONT> D <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>Delta <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;G_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT> 
        <FONT COLOR="#007FFF"><TT>|</TT></FONT> empty                 <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> empty       
        <FONT COLOR="#007FFF"><TT>|</TT></FONT> G , x : T             <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> term        
</PRE><P>
permitting the user to write <CODE>G'</CODE>, <CODE>D12</CODE> etc.&#XA0;in symbolic
terms, to be typeset as 

<IMG SRC="top2004.gif">etc.</P><!--TOC subsection Using the LaTeX code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">4.3</A>&#XA0;&#XA0;Using the LaTeX code</H3><!--SEC END --><P><A NAME="a64"></A>The generated LaTeX code can be used in two main ways. 
By default, Ott generates a stand-alone LaTeX file, 
with a standard wrapper (including a <CODE>\documentclass</CODE>, various
macro definitions, and a main body),
that gives the complete system definition.</P><P>The default header can be overridden by writing
<CODE> embed {{ tex-wrap-pre ... }} </CODE> and the default footer by
writing <CODE>embed {{ tex-wrap-post ... }} </CODE>. Alternatively, the
program option <CODE>-tex_wrap false</CODE> with the <CODE>-tex_wrap false</CODE>
command-line argument, one can generate a file that can be included in
other LaTeX files, that just defines macros to typeset various
parts of the system (<CODE>-tex_wrap false</CODE> overrides any
<CODE>tex-wrap-pre/tex-wrap-post</CODE> embeds).</P><P>The generated LaTeX output is factored into individual LaTeX
commands: for the metavariable declarations, each rule of the syntax
definition, the collected syntax (<CODE>\ottgrammar</CODE>), each rule of the inductive relation
definitions, the collected rules for each relation, the collected
rules for each <CODE>defns</CODE> block, the union of those
(<CODE>\ottdefns</CODE>) and the whole (<CODE>\ottall</CODE>). 
This makes it possible to quote individual parts of the definition,
possibly out-of-order, in a paper or technical report. </P><P>If one needs to include more than one system in a single LaTeX
document, the <CODE>ott</CODE> prefix can be replaced using the
<CODE>-tex_name_prefix</CODE> command-line argument. </P><P>The generated LaTeX is factored through some common style macros, 
e.g.&#XA0;to typeset a comment, a production, and a grammar. If necessary
these can be redefined in an <FONT COLOR="#A51815"><TT>embed</TT></FONT> block (see Section&#XA0;<A HREF="#a60">8.1</A>). 
For example, the file <CODE>tests/squishtex.ott</CODE>
</P><PRE>
<FONT COLOR="#A51815"><TT>embed</TT></FONT> 
 <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> tex-preamble
<TT>\</TT>renewcommand<TT>{</TT><TT>\</TT><FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>TEX_NAME_PREFIX</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT>grammartabular<TT>}</TT>[1]
  <TT>{</TT><TT>\</TT>begin<TT>{</TT>minipage<TT>}</TT><TT>{</TT><TT>\</TT>columnwidth<TT>}</TT><TT>\</TT>begin<TT>{</TT>tabular<TT>}</TT><TT>{</TT>ll<TT>}</TT>#1<TT>\</TT>end<TT>{</TT>tabular<TT>}</TT><TT>\</TT>end<TT>{</TT>minipage<TT>}</TT> <TT>}</TT>
<TT>\</TT>renewcommand<TT>{</TT><TT>\</TT><FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>TEX_NAME_PREFIX</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT>rulehead<TT>}</TT>[3]
  <TT>{</TT>$#1$  $#2$ &amp; $#3$<TT>}</TT>
<TT>\</TT>renewcommand<TT>{</TT><TT>\</TT><FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>TEX_NAME_PREFIX</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT>prodline<TT>}</TT>[6]
  <TT>{</TT> <TT>\</TT>quad $#1$ <TT>\</TT> $#2$ &amp; <TT>\</TT>quad $#3 #4$  $#5$  $#6$<TT>}</TT>
<TT>\</TT>renewcommand<TT>{</TT><TT>\</TT><FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>TEX_NAME_PREFIX</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT>interrule<TT>}</TT>
  <TT>{</TT><TT>\</TT><TT>\</TT>[2.0mm]<TT>}</TT>
 <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>

defines a more compact style for grammars. Note that the
<TT><FONT COLOR="#007FFF">[[</FONT></TT><TT><FONT COLOR="#A51815">TEX_NAME_PREFIX</FONT></TT><TT><FONT COLOR="#007FFF">]]</FONT></TT> is replaced by whatever prefix is in force,
so such style files can be reused in different contexts.</P><P>A more sophisticated LaTeX package <CODE>ottlayout.sty</CODE>, providing fine control of how
inference rules and grammars should be typeset, is contained in the
<CODE>tex</CODE> directory of the distribution. It is described in the
manual therein.</P><!--TOC section Generating proof assistant definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc14">5</A>&#XA0;&#XA0;Generating proof assistant definitions</H2><!--SEC END --><P><A NAME="a52"></A>To generate proof assistant definitions, for Coq, Isabelle, and HOL,
the minimal Ott source file of Section&#XA0;<A HREF="#a51">3</A>/Figure&#XA0;<A HREF="#a45">1</A> must
be extended with a modest amount of additional data, as shown in Figure&#XA0;<A HREF="#a47">4</A>.
Executing 
</P><PRE>
   bin/ott  -i tests/test10.4.ott  -o out.v  -o out.thy  -o outScript.sml 
</PRE><P>
generates Coq <TT>out.v</TT>, Isabelle <TT>out.thy</TT>, and HOL
<TT>outScript.sml</TT>, shown in Figures&#XA0;<A HREF="#a6">5</A>, <A HREF="#a5">6</A>, and <A HREF="#a40">7</A>.
The additional data can be combined with the annotations for
LaTeX of the previous section, but those are omitted here. 
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="minipage"><SPAN CLASS="textboxed">
</SPAN><PRE><SPAN CLASS="textboxed">
% minimal                    + binding + subst + coq/hol/isa
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>metavar</TT></FONT></SPAN><SPAN CLASS="textboxed"> termvar</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>,</TT></FONT></SPAN><SPAN CLASS="textboxed"> x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">  
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>isa</TT></FONT></SPAN><SPAN CLASS="textboxed"> string</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>coq</TT></FONT></SPAN><SPAN CLASS="textboxed"> nat</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>hol</TT></FONT></SPAN><SPAN CLASS="textboxed"> string</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>coq-equality</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>grammar</TT></FONT></SPAN><SPAN CLASS="textboxed">
t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;t_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">                               
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> x            </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Var                  
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed"> x . t      </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam     </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>(+</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>bind</TT></FONT></SPAN><SPAN CLASS="textboxed"> x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>in</TT></FONT></SPAN><SPAN CLASS="textboxed"> t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>+)</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> t t&#X2019;         </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> App                  
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> ( t )        </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>S</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Paren   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>icho</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> 
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed"> t / x </SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed"> t&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>M</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Tsub    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>icho</TT></FONT></SPAN><SPAN CLASS="textboxed"> (tsubst_t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">x</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t&#X2019;</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed">)</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">

v </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;v_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">                              
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed"> x . t      </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam                

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>subrules</TT></FONT></SPAN><SPAN CLASS="textboxed">
  v </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>&lt;::</TT></FONT></SPAN><SPAN CLASS="textboxed"> t

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>substitutions</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>single</TT></FONT></SPAN><SPAN CLASS="textboxed"> t x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> tsubst 

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defns</TT></FONT></SPAN><SPAN CLASS="textboxed">
Jop </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X201D; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">

 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defn</TT></FONT></SPAN><SPAN CLASS="textboxed">
 t1 &#X2013;&gt; t2 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">reduce</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">&#X201D;  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>by</TT></FONT></SPAN><SPAN CLASS="textboxed">


</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------------------</TT></FONT></SPAN><SPAN CLASS="textboxed">  :: ax_app
    (</SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">x.t12) v2 &#X2013;&gt;  </SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed">v2/x</SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed">t12

    t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: ctx_app_fun
    t1 t &#X2013;&gt; t1&#X2019; t

    t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: ctx_app_arg
    v t1 &#X2013;&gt; v t1&#X2019;
</SPAN></PRE><SPAN CLASS="textboxed">

</SPAN></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 4: Source: <TT>test10.4.ott</TT><A NAME="a47"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>
We add four things.
First, we specify proof assistant types to represent object-language
variables &#X2014; in this example, choosing the <TT>string</TT> type of
Isabelle and HOL, and the <TT>nat</TT> type for Coq:
</P><PRE>
  <FONT COLOR="#A51815"><TT>metavar</TT></FONT> termvar<FONT COLOR="#007FFF"><TT>,</TT></FONT> x <FONT COLOR="#007FFF"><TT>::=</TT></FONT>  
  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> string<FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq</TT></FONT> nat<FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>hol</TT></FONT> string<FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq-equality</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
For Coq output, one can specify <CODE>{{ coq-equality</CODE> <I>proof-script</I> <CODE>}}</CODE>
to build a decidable equality over the Coq representation type using
the proof <I>proof-script</I>. If the script is omitted, as in this
example, it defaults
to 
</P><PRE CLASS="verbatim">Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
</PRE><P>where the <CODE>ott_coq_equality</CODE> database contains the decidable
equalities of the representation types defined in the source. It is
possible to suppress type generation for specific metavariables or nonterminals, by adding the
declaration <CODE>{{ phantom }}</CODE>. This is useful in some cases, for
instance to avoid duplicate definitions of types already defined in an
imported library. Any type homs are taken into account when
the metavariable or nonterminal root is output as a type.</P><P>Second, we specify what the binding is in the object language, with
the <TT><FONT COLOR="#007FFF">(+</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">bind</FONT></TT><TT> x </TT><TT><FONT COLOR="#A51815">in</FONT></TT><TT> t </TT><TT><FONT COLOR="#007FFF">+)</FONT></TT>
annotation on the <TT>Lam</TT> production:
</P><PRE>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT> x . t      <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam     <FONT COLOR="#007FFF"><TT>(+</TT></FONT> <FONT COLOR="#A51815"><TT>bind</TT></FONT> x <FONT COLOR="#A51815"><TT>in</TT></FONT> t <FONT COLOR="#007FFF"><TT>+)</TT></FONT>
</PRE><P>
Section&#XA0;<A HREF="#a62">9</A> describes the full language of binding specifications.</P><P>Third, we add a block
</P><PRE>
  <FONT COLOR="#A51815"><TT>substitutions</TT></FONT>
    <FONT COLOR="#A51815"><TT>single</TT></FONT> t x <FONT COLOR="#007FFF"><TT>::</TT></FONT> tsubst 
</PRE><P>
to cause Ott to generate Coq/Isabelle/HOL definitions of a substitution
function, with name root <TT>tsubst</TT>, replacing metavariables <TT>x</TT> by terms <TT>t</TT>. This is for single
substitutions; multiple substitution functions (taking lists of
substitutand/substitutee pairs) can also be generated with the keyword
<FONT COLOR="#A51815"><TT>multiple</TT></FONT>. 
Substitution functions are generated for all rules of the grammar for
which they might be required &#X2014; here, just over <CODE>t</CODE>, with a
function named <CODE>tsubst_t</CODE>.</P><P>Finally, we specify translations for the metaproductions:
</P><PRE>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> ( t )        <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>S</TT></FONT><FONT COLOR="#007FFF"><TT>::</TT></FONT> Paren   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>icho</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT>  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>{</TT> t / x <TT>}</TT> t&#X2019; <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT><FONT COLOR="#007FFF"><TT>::</TT></FONT> Tsub    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>icho</TT></FONT> (tsubst_t <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>x<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT>)<FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
These specify that <TT>(t)</TT> should be translated into just the
translation of <TT>t</TT>, whereas 
<TT>{</TT><TT>t/x</TT><TT>}</TT><TT>t&#X2019;</TT> should be translated into the
proof-assistant application of <TT>tsubst_t</TT> to the translations
of <TT>t</TT>, <TT>x</TT>, and <TT>t&#X2019;</TT>.
The (admittedly terse) <FONT COLOR="#A51815"><TT>icho</TT></FONT> specifies that these translations should be
done uniformly for Isabelle, Coq, HOL, and OCaml output. One can also
specify just one of these, writing
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">coq</FONT></TT><TT> </TT>&#X2026;<TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>, 
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">hol</FONT></TT><TT> </TT>&#X2026;<TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>, 
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">isa</FONT></TT><TT> </TT>&#X2026;<TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>, or 
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">ocaml</FONT></TT><TT> </TT>&#X2026;<TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>,
or include several, with different translations for each.
There are also abbreviated forms <FONT COLOR="#A51815"><TT>ich</TT></FONT>, <FONT COLOR="#A51815"><TT>ic</TT></FONT>, <FONT COLOR="#A51815"><TT>ch</TT></FONT>, and <FONT COLOR="#A51815"><TT>ih</TT></FONT>.
The body of a proof assistant hom should normally include outer
parentheses, as in the <TT>Tsub</TT> hom above, so that it is
parsed correctly by the proof assistant in all contexts.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="minipage"><SPAN CLASS="textboxed">
</SPAN><PRE CLASS="verbatim"><SPAN CLASS="textboxed">(* generated by Ott 0.25 from: ../tests/test10.ott ../tests/non_super_tabular.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.


Definition var := nat. (*r term variable *)
Lemma eq_var: forall (x y : var), {x = y} + {x &lt;&gt; y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_var : ott_coq_equality.

Inductive term : Set :=  (*r term *)
 | t_var (x:var) (*r variable *)
 | t_lam (x:var) (t:term) (*r lambda *)
 | t_app (t:term) (t':term) (*r app *).

(** subrules *)
Definition is_val_of_term (t5:term) : Prop :=
  match t5 with
  | (t_var x) =&gt; False
  | (t_lam x t) =&gt; (True)
  | (t_app t t') =&gt; False
end.

(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a&lt;&gt;b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil =&gt; false
  | cons h t =&gt; if eq h x then true else list_mem A eq x t
end.
Implicit Arguments list_mem.


(** substitutions *)
Fixpoint tsubst_term (t5:term) (x5:var) (t_6:term) {struct t_6} : term :=
  match t_6 with
  | (t_var x) =&gt; (if eq_var x x5 then t5 else (t_var x))
  | (t_lam x t) =&gt; t_lam x (if list_mem eq_var x5 (cons x nil) then t else (tsubst_term t5 x5 t))
  | (t_app t t') =&gt; t_app (tsubst_term t5 x5 t) (tsubst_term t5 x5 t')
end.

(** definitions *)

(* defns Jop *)
Inductive reduce : term -&gt; term -&gt; Prop :=    (* defn reduce *)
 | ax_app : forall (x:var) (t1 v2:term),
     is_val_of_term v2 -&gt;
     reduce (t_app  (t_lam x t1)  v2)  (tsubst_term  v2   x   t1 ) 
 | ctx_app_fun : forall (t1 t t1':term),
     reduce t1 t1' -&gt;
     reduce (t_app t1 t) (t_app t1' t)
 | ctx_app_arg : forall (v t1 t1':term),
     is_val_of_term v -&gt;
     reduce t1 t1' -&gt;
     reduce (t_app v t1) (t_app v t1').


</SPAN></PRE><SPAN CLASS="textboxed">
</SPAN></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 5: Generated Coq:<TT>test10.v</TT><A NAME="a6"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="minipage"><SPAN CLASS="textboxed">
</SPAN><PRE CLASS="verbatim"><SPAN CLASS="textboxed">(* generated by Ott 0.25 from: ../tests/test10.ott ../tests/non_super_tabular.ott *)
theory test10
imports Main "~~/src/HOL/Library/Multiset"
begin

types "var" = "string" -- {* term variable *}
datatype "term" =  -- {* term *}
   t_var "var"   -- {* variable *}
 | t_lam "var" "term"   -- {* lambda *}
 | t_app "term" "term"   -- {* app *}


(** subrules *)
primrec
is_val_of_term :: "term =&gt; bool"
where
"is_val_of_term (t_var x) = (False)"
| "is_val_of_term (t_lam x t) = ((True))"
| "is_val_of_term (t_app t t') = (False)"


(** substitutions *)
primrec
tsubst_term :: "term =&gt; var =&gt; term =&gt; term"
where
"tsubst_term t5 x5 (t_var x) = ((if x=x5 then t5 else (t_var x)))"
| "tsubst_term t5 x5 (t_lam x t) = (t_lam x (if x5 : set [x] then t else (tsubst_term t5 x5 t)))"
| "tsubst_term t5 x5 (t_app t t') = (t_app (tsubst_term t5 x5 t) (tsubst_term t5 x5 t'))"

(** definitions *)
(* defns Jop *)
inductive reduce :: "term \&lt;Rightarrow&gt; term \&lt;Rightarrow&gt; bool"
where
(* defn reduce *)

ax_appI: "\&lt;lbrakk&gt;is_val_of_term v2\&lt;rbrakk&gt; \&lt;Longrightarrow&gt;
reduce ((t_app  (t_lam x t1)  v2)) ( (tsubst_term  v2   x   t1 ) )"

| ctx_app_funI: "\&lt;lbrakk&gt;reduce (t1) (t1')\&lt;rbrakk&gt; \&lt;Longrightarrow&gt;
reduce ((t_app t1 t)) ((t_app t1' t))"

| ctx_app_argI: "\&lt;lbrakk&gt;is_val_of_term v ;
reduce (t1) (t1')\&lt;rbrakk&gt; \&lt;Longrightarrow&gt;
reduce ((t_app v t1)) ((t_app v t1'))"

end



</SPAN></PRE><SPAN CLASS="textboxed">
</SPAN></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 6: Generated Isabelle:<TT>test10.thy</TT><A NAME="a5"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="minipage"><SPAN CLASS="textboxed">
</SPAN><PRE CLASS="verbatim"><SPAN CLASS="textboxed">(* generated by Ott 0.25 from: ../tests/test10.ott ../tests/non_super_tabular.ott *)
(* to compile: Holmake test10Theory.uo   *)
(* for interactive use:
  app load ["pred_setTheory","finite_mapTheory","stringTheory","containerTheory","ottLib"];
*)

open HolKernel boolLib Parse bossLib ottLib;
infix THEN THENC |-&gt; ## ;
local open arithmeticTheory stringTheory containerTheory pred_setTheory listTheory 
  finite_mapTheory in end;

val _ = new_theory "test10";


val _ = type_abbrev("var", ``:string``); (* term variable *)
val _ = Hol_datatype ` 
term =  (* term *)
   t_var of var (* variable *)
 | t_lam of var =&gt; term (* lambda *)
 | t_app of term =&gt; term (* app *)
`;

(** subrules *)
val _ = ottDefine "is_val_of_term" `
    ( is_val_of_term (t_var x) = F)
/\  ( is_val_of_term (t_lam x t) = (T))
/\  ( is_val_of_term (t_app t t') = F)
`;

(** substitutions *)
val _ = ottDefine "tsubst_term" `
    ( tsubst_term t5 x5 (t_var x) = (if x=x5 then t5 else (t_var x)))
/\  ( tsubst_term t5 x5 (t_lam x t) = t_lam x (if MEM x5 [x] then t else (tsubst_term t5 x5 t)))
/\  ( tsubst_term t5 x5 (t_app t t') = t_app (tsubst_term t5 x5 t) (tsubst_term t5 x5 t'))
`;
(** definitions *)
(* defns Jop *)

val (Jop_rules, Jop_ind, Jop_cases) = Hol_reln`
(* defn reduce *)

( (* ax_app *) ! (x:var) (t1:term) (v2:term) . (clause_name "ax_app") /\
((is_val_of_term v2))
 ==&gt; 
( ( reduce (t_app  (t_lam x t1)  v2)  (tsubst_term  v2   x   t1 )  )))

/\ ( (* ctx_app_fun *) ! (t1:term) (t:term) (t1':term) . (clause_name "ctx_app_fun") /\
(( ( reduce t1 t1' )))
 ==&gt; 
( ( reduce (t_app t1 t) (t_app t1' t) )))

/\ ( (* ctx_app_arg *) ! (v:term) (t1:term) (t1':term) . (clause_name "ctx_app_arg") /\
((is_val_of_term v) /\
( ( reduce t1 t1' )))
 ==&gt; 
( ( reduce (t_app v t1) (t_app v t1') )))

`;

val _ = export_theory ();



</SPAN></PRE><SPAN CLASS="textboxed">
</SPAN></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 7: Generated HOL:<TT>test10Script.sml</TT><A NAME="a40"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Proof assistant code for grammar rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc15">5.1</A>&#XA0;&#XA0;Proof assistant code for grammar rules</H3><!--SEC END --><P>
The normal behaviour is to generate a free proof assistant type for
each (non-subrule, non-phantom) grammar rule. 
For example, the Coq compilation for <TT>t</TT> here generates a free type with three
constructors:
</P><PRE CLASS="verbatim">  Inductive term : Set := 
   | t_var (x:var)
   | t_lam (x:var) (t:term)
   | t_app (t:term) (t':term).
</PRE><P>(note that the metaproductions do not give rise to constructors). </P><P>Remark: prior to version 0.20.2, the free type generated for Coq was 
</P><PRE CLASS="verbatim">  Inductive term : Set := 
   | t_var : var -&gt; term
   | t_lam : var -&gt; term -&gt; term
   | t_app : term -&gt; term -&gt; term.
</PRE><P>but we found that trying to preserve the names specified by the user
is helpful later, when doing proofs. Whenever a clash is detected, or
for list forms, the wildcard <TT>_</TT> is used. The old behaviour
can be obtained via the top-level option
<TT>-coq_names_in_rules false</TT>.</P><P>By default the order of the arguments to those constructors follows
the order in which they appear in the production. That can be
overridden with an <TT>order</TT> hom. For example, if for some
reason (perhaps compatibility with other Coq code) one wished the
arguments to <CODE>t_Lam</CODE> to be reversed:
</P><PRE CLASS="verbatim">   | t_Lam : t -&gt; termvar -&gt; t
</PRE><P>one could add an <FONT COLOR="#A51815"><TT>order</TT></FONT> hom as below.
</P><PRE>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT> x . t      <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>order</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>x<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>Instead of using the generated free type, one can specify an arbitrary proof assistant representation type,
annotating the grammar rule with a <FONT COLOR="#A51815"><TT>coq</TT></FONT>, <FONT COLOR="#A51815"><TT>isa</TT></FONT>, <FONT COLOR="#A51815"><TT>hol</TT></FONT>, or <FONT COLOR="#A51815"><TT>ocaml</TT></FONT> hom &#X2014;
for example, in the following grammar for substitutions.
</P><PRE>
  s <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>sigma <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;S_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> multiple subst <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> (termvar*t) list <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
       <FONT COLOR="#007FFF"><TT>|</TT></FONT> [ x |-&gt; t ]            <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> singleton   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> [ (<FONT COLOR="#007FFF"><TT>[[</TT></FONT>x<FONT COLOR="#007FFF"><TT>]]</TT></FONT>,<FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT>) ]  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
       <FONT COLOR="#007FFF"><TT>|</TT></FONT> s1 , <FONT COLOR="#007FFF"><TT>..</TT></FONT> , sn           <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> list        <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> List.concat <FONT COLOR="#007FFF"><TT>[[</TT></FONT>s1 <FONT COLOR="#007FFF"><TT>..</TT></FONT> sn<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
Here the <TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">isa</FONT></TT><TT> (termvar*t) list </TT><TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT> hom specifies that in
Isabelle output this type be represented as an Isabelle
<CODE>(termvar*t) list</CODE> instead of the default free inductive type;
all the productions are metaproductions (tagged <FONT COLOR="#A51815"><TT>M</TT></FONT>); and <FONT COLOR="#A51815"><TT>isa</TT></FONT> homs for each production specify how they should be translated into that Isabelle type.
This feature must be used with care, as any Ott-generated functions, e.g.&#XA0;substitution functions, cannot recurse through such user-defined types. </P><P>Grammar rules (whether free or non-free) can also include a <FONT COLOR="#A51815"><TT>coq equality</TT></FONT> hom, instructing
the Coq code generator to derive a decidable equality for the Coq
representation type. For example, the ML polymorphism Ott source of
<TT>test8.ott</TT> includes the following.
</P><PRE>
  typvar <FONT COLOR="#007FFF"><TT>::</TT></FONT> TV_ <FONT COLOR="#007FFF"><TT>::=</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq-equality</TT></FONT> decide equality. apply eq_value_name_t. <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
       <FONT COLOR="#007FFF"><TT>|</TT></FONT> &#X2019; ident                <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> ident
</PRE><P>The Coq/HOL/Isabelle/OCaml type name for a grammar rule, or for a
metavariable declaration, is normally
taken to be just its primary nonterminal root. 
Occasionally it is useful to work around a clash between a
metavar or nonterminal primary root and a proof assistant symbol,
e.g.&#XA0;<TT>T</TT> in HOL or <TT>value</TT> in Isabelle. 
For this, one can add a <FONT COLOR="#A51815"><TT>coq</TT></FONT>, <FONT COLOR="#A51815"><TT>hol</TT></FONT>, <FONT COLOR="#A51815"><TT>isa</TT></FONT>, or
<FONT COLOR="#A51815"><TT>ocaml</TT></FONT> hom to the primary nonterminal root. In the example
below, the user can write <TT>T</TT>, <TT>T&#X2019;</TT> etc. in their Ott
source, but the generated HOL type is <TT>Typ</TT>.
</P><PRE>
T <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>hol</TT></FONT> Typ <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>,</TT></FONT> S<FONT COLOR="#007FFF"><TT>,</TT></FONT> U <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;T_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>                    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> type  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> T -&gt; T&#X2019;                          <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Fun          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> type of functions <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>The grammar rules within each <FONT COLOR="#A51815"><TT>grammar</TT></FONT> block of a syntax definition may depend on each other arbitrarily.
When generating Isabelle/Coq/HOL/OCaml representation types, however, they are
topologically sorted, to simplify the resulting induction
principles.</P><!--TOC subsection Proof assistant code for inductive definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc16">5.2</A>&#XA0;&#XA0;Proof assistant code for inductive definitions</H3><!--SEC END --><P>
The semantic relations are defined
with the proof-assistant inductive relations packages, 
<CODE>Inductive</CODE>, <CODE>Hol_reln</CODE>, and <CODE>inductive_set</CODE> or <CODE>inductive</CODE>, respectively.
Each <FONT COLOR="#A51815"><TT>defns</TT></FONT> block gives rise to a potentially mutually
recursive definition of each <FONT COLOR="#A51815"><TT>defn</TT></FONT> inside it
(it seems clearer not to do a topological sort here).
Definition rules are expressed internally with symbolic terms. 
We give a simplified grammar thereof in Fig.&#XA0;<A HREF="#a19">17</A>, omitting the
symbolic terms for list forms. 
A symbolic term <I><I>st</I></I> for a nonterminal root is either an explicit nonterminal or a
node, the latter labelled with a production name and containing a list of
<I><I>symterm</I>_<I>element</I></I>s, which in turn are either symbolic terms,
metavariables, or variables.
Each definition rule 
gives rise to an implicational clause, essentially
that the premises (Ott symbolic terms of the <FONT COLOR="#A51815"><TT>formula</TT></FONT> grammar)
imply the conclusion (an Ott symbolic term of whichever judgement is
being defined). 
Symbolic terms are compiled in several different ways:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Nodes of non-meta productions are output as applications of the appropriate proof-assistant constructor (and, for a subrule, promoted to the corresponding constructor of a maximal rule).
</LI><LI CLASS="li-itemize">Nodes of meta productions are transformed with the user-specified homomorphism.
</LI><LI CLASS="li-itemize">Nodes of judgement forms are represented as applications of the defined relation in Coq and HOL, and as set-membership assertions in Isabelle.
</LI><LI CLASS="li-itemize">Lists of formulae (the <CODE>formula_dots</CODE> production, c.f.&#XA7;<A HREF="#a61">12</A>) are
special-cased to proof-assistant conjunctions.
</LI></UL><P>
Further, for each nonterminal of a non-free grammar rule,
e.g.&#XA0;a usage of <CODE>v'</CODE> where <CODE>v&lt;::t</CODE>, an additional premise
invoking the generated subrule predicate for the non-free rule is added, e.g.&#XA0;<CODE>is_v v'</CODE>.
For Coq and HOL, explicit quantifiers are introduced for all variables
mentioned in the rule.
For HOL, rules are tagged with their rule name (using <CODE>clause_name</CODE>).</P><!--TOC subsection Representation of binding-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc17">5.3</A>&#XA0;&#XA0;Representation of binding</H3><!--SEC END --><P>
At present the generated Isabelle/Coq/HOL uses fully concrete
representations of variables in terms, without any notion of alpha
equivalence, as one can see in Fig.&#XA0;<A HREF="#a5">6</A>:
see the <CODE>t</CODE> datatype of terms and the <CODE>tsubst_t</CODE>
substitution function there. 
An experimental Coq backend generates definitions in locally-nameless style for a subset of the Ott metalanguage. This is work-in-progress, and it is extensively documented in <A HREF="http://moscova.inria.fr/&#XA0;zappa/projects/ln_ott/"><TT>http://moscova.inria.fr/&#XA0;zappa/projects/ln_ott/</TT></A>.
We intend in future to generate other representations, and in some
circumstances homs can be used to implement other representations directly.
For a reasonably wide variety of
languages, however, one can capture the intended semantics of whole programs in
this idiom, subject only to the condition that standard library
identifiers are not shadowed within the program, as the operational
semantics does not involve reduction under binders &#X2014; so any
substitutions are of terms which (except for standard library
identifiers) are closed. This includes the ML polymorphism example of
<TT>test8.ott</TT>. For languages which require a type
environment with internal dependencies, however, for example F<SUB>&lt;:</SUB>, this is
no longer the case. The POPLmark F<SUB>&lt;:</SUB> example given in <TT>test7.ott</TT>
has a type system which disallows all shadowing, a property that is
not preserved by reduction. However, a correct translation of F<SUB>&lt;:</SUB> is generated by the Coq locally-nameless backend, and can be found in <A HREF="http://moscova.inria.fr/&#XA0;zappa/projects/ln_ott/"><TT>http://moscova.inria.fr/&#XA0;zappa/projects/ln_ott/</TT></A>.</P><P>Further discussion of binding representations is in the Ott ICFP 2007
paper and in a working draft 
</P><BLOCKQUOTE CLASS="quotation">Binding and Substitition. Susmit Sarkar, Peter Sewell, and Francesco
Zappa Nardelli. August 2007.
</BLOCKQUOTE><P>
available from the Ott web page.</P><!--TOC subsection Helper functions for free variable and substitution functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc18">5.4</A>&#XA0;&#XA0;Helper functions for free variable and substitution functions</H3><!--SEC END --><P>The generated free variable and substitution functions in the Coq output 
(e.g., in Figure&#XA0;<A HREF="#a6">5</A>) often rely on a few standard library functions: 
<CODE>list_mem</CODE>, <CODE>list_assoc</CODE>, <CODE>list_minus</CODE>, <CODE>list_minus2</CODE>.
In order to avoid dependencies on external libraries for defining those
functions, by default Ott generates the definitions for any such functions it
uses. It is possible to turn off the generation of definitions for 
these such functions by writing the following directive early on in the source file: </P><PRE>
<FONT COLOR="#A51815"><TT>embed</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq-lib</TT></FONT> list_mem list_minus <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>This instructs Ott to avoid generating definition for <CODE>list_mem</CODE> and
<CODE>list_minus</CODE>, but to continue generating definitions for other functions
such as <CODE>list_assoc</CODE> and <CODE>list_minus2</CODE>.</P><P><B>Note about </B><CODE>list_minus2</CODE><B>:</B> 
Instead of using the function <CODE>list_minus2</CODE>, earlier versions of Ott
generated equivalent code based on <CODE>list_filter</CODE>, which was more
difficult to reason about. For backwards compatibility, however, we provide the
command-line option <CODE>-coq_use_filter_fn</CODE> for generating a definition using
the older code pattern.</P><!--TOC subsection Correctness of the generated proof assistant code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc19">5.5</A>&#XA0;&#XA0;Correctness of the generated proof assistant code</H3><!--SEC END --><P>
We have attempted to ensure that the proof assistant definitions
generated by Ott are well-formed and what the user would intend. This
is not guaranteed, however, for several reasons: (1) There may be name
clashes between Ott-generated identifiers and proof assistant built-in
identifiers (or, in pathological cases, even among different
Ott-generated identifiers). (2) In some cases we depend on automatic
proof procedures, e.g.&#XA0;for HOL definitions. These work in our test
cases, but it is hard to ensure that they will in all cases. More
importantly, (3) the generation process is complex, so it is quite
possible that there is either a bug in Ott or a mismatch between the
user expectation and what the tool actually does. Ultimately one has
to read the generated proof assistant definitions to check that they
are as intended &#X2014; but typically one would do this in any case, many
times over, in the process of proving metatheoretic results, so we do
not consider it a major issue.</P><!--TOC subsection Using the generated proof assistant code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc20">5.6</A>&#XA0;&#XA0;Using the generated proof assistant code</H3><!--SEC END --><P>
Ott builds code for </P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>Coq 8.3</TD><TD ALIGN=left NOWRAP><A HREF="http://coq.inria.fr/"><TT>http://coq.inria.fr/</TT></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>HOL 4 (the current svn version)</TD><TD ALIGN=left NOWRAP><A HREF="http://hol.sourceforge.net/"><TT>http://hol.sourceforge.net/</TT></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>Isabelle/HOL (Isabelle 2011)</TD><TD ALIGN=left NOWRAP><A HREF="http://isabelle.in.tum.de/"><TT>http://isabelle.in.tum.de/</TT></A></TD></TR>
</TABLE><P>Given proof assistant files in the top-level directory of the
distribution, as produced at the start of this section
(Coq <TT>out.v</TT>, Isabelle <TT>out.thy</TT>, and HOL
<TT>outScript.sml</TT>), the various proof assistants can be invoked as follows.</P><!--TOC subsubsection Coq-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc21">5.6.1</A>&#XA0;&#XA0;Coq</H4><!--SEC END --><P>
First run 
</P><PRE CLASS="verbatim">  make
</PRE><P>in the <TT>coq</TT> directory of the distribution, to build the auxiliary files.
These include a core file (<CODE>ott_list_core</CODE>) of definitions that
are used in Ott-generated output. 
At present these are only required when Coq native lists are used. 
There are also various lemmas (in
<CODE>ott_list.v</CODE>) which may be useful; they can be made available with
<CODE>Require Import ott_list.</CODE> </P><P>For batch mode run
</P><PRE CLASS="verbatim">  coqc -I coq  out.v
</PRE><P>where <CODE>coq</CODE> is the path to the <CODE>coq</CODE> directory of the distribution.</P><P>The experimental locally-nameless backend requires the <CODE>Metatheory</CODE> library by Arthur Chargueraud, available from the project web page.</P><!--TOC subsubsection HOL-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc22">5.6.2</A>&#XA0;&#XA0;HOL</H4><!--SEC END --><P>
First run 
</P><PRE CLASS="verbatim">  Holmake
</PRE><P>in the <TT>hol</TT> directory of the distribution, to build the auxiliary files.</P><P>For
batch mode run
</P><PRE CLASS="verbatim">  Holmake -I hol  outTheory.uo
</PRE><P>where <CODE>hol</CODE> is the path to the <CODE>hol</CODE> directory of the distribution.
For interactive mode, run 
</P><PRE CLASS="verbatim">  hol -I hol
</PRE><P>inside an editor window (where the second <CODE>hol</CODE> is again the path
to the <CODE>hol</CODE> directory of the distribution), and in
another window view the <CODE>outScript.sml</CODE> file. First
paste in the <CODE>app load</CODE> command from a comment at the top of the
file, then paste in the remainder.</P><!--TOC subsubsection Isabelle-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc23">5.6.3</A>&#XA0;&#XA0;Isabelle</H4><!--SEC END --><P>
For batch mode:
</P><PRE CLASS="verbatim">  echo 'ML_command {* (use_thy "Tmp"; OS.Process.exit OS.Process.success) handle e =&gt; (OS.Process.exit OS.Process.failure); *}' | /usr/local/Isabelle/bin/isabelle tty 
</PRE><P>Interactively, using Proof General:
</P><PRE CLASS="verbatim">  isabelle emacs out.thy
</PRE><!--TOC section Judgments and formulae-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">6</A>&#XA0;&#XA0;Judgments and formulae</H2><!--SEC END --><P><A NAME="a53"></A>In a semantic rule, for example
</P><PRE>
    t1 &#X2013;&gt; t1&#X2019;
<FONT COLOR="#007FFF"><TT>    -------------- ::</TT></FONT> ctx_app_arg
    v t1 &#X2013;&gt; v t1&#X2019;
</PRE><P>
the conclusion must be a symbolic term of the form of the judgement being
defined, but in general the premises may be symbolic terms
of a <FONT COLOR="#A51815"><TT>formula</TT></FONT> grammar or in-line embedded prover code.
By default the formula grammar includes all the defined judgement forms: for the
running example Ott will synthesise grammars as below.</P><P><IMG SRC="top2005.gif"></P><P>The user can also define an explicit formula grammar, to let other
forms (not just judgements) appear as rule premises. Below is a
fragment of the formula grammar from the LJ example on the Ott web page.
</P><PRE>
  <FONT COLOR="#A51815"><TT>formula</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> formula_ <FONT COLOR="#007FFF"><TT>::=</TT></FONT>  
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  judgement                       <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> judgement
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  formula1 <FONT COLOR="#007FFF"><TT>..</TT></FONT> formulan            <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> dots
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  not <FONT COLOR="#A51815"><TT>formula</TT></FONT>                     <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> not
          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>neg <FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> <TT>\</TT>&lt;not&gt; (<FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT>) <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  ( <FONT COLOR="#A51815"><TT>formula</TT></FONT> )                     <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> brackets
          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> (<FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT><TT>\</TT>!) <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>  
          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  <FONT COLOR="#A51815"><TT>formula</TT></FONT> <TT>\</TT>/ <FONT COLOR="#A51815"><TT>formula</TT></FONT>&#X2019;             <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> or
          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT> <TT>\</TT>vee <FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT>&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT> <TT>\</TT>&lt;or&gt; <FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT>&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  <FONT COLOR="#A51815"><TT>formula</TT></FONT> /<TT>\</TT> <FONT COLOR="#A51815"><TT>formula</TT></FONT>&#X2019;             <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> and
          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT> <TT>\</TT>wedge <FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT>&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT><FONT COLOR="#007FFF"><TT>]]</TT></FONT> <TT>\</TT>&lt;and&gt; <FONT COLOR="#007FFF"><TT>[[</TT></FONT><FONT COLOR="#A51815"><TT>formula</TT></FONT>&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  x = x&#X2019;                          <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> xali
          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>x<FONT COLOR="#007FFF"><TT>]]</TT></FONT> = <FONT COLOR="#007FFF"><TT>[[</TT></FONT>x&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  X = X&#X2019;                          <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Xali
          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>X<FONT COLOR="#007FFF"><TT>]]</TT></FONT> = <FONT COLOR="#007FFF"><TT>[[</TT></FONT>X&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
This example adds (to the judgement forms) syntax for parenthesised
formulae, negation, and, or, and equality testing on two sorts. For
each, <FONT COLOR="#A51815"><TT>tex</TT></FONT> and <FONT COLOR="#A51815"><TT>isa</TT></FONT> homs specify how they should be
typeset and be translated into Isabelle.</P><P>If the user defines a <FONT COLOR="#A51815"><TT>formula</TT></FONT> grammar then (as here) the production
name prefix must be <TT>formula_</TT> and the name for the
<TT>judgement</TT> production must be <TT>judgement</TT>.</P><!--TOC subsection Naming of premises for the Coq backend-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc25">6.1</A>&#XA0;&#XA0;Naming of premises for the Coq backend</H3><!--SEC END --><P>
It is possible to specify the names of premises of inductive
predicates; these names are then used by the Coq backend, and are
often useful in proofs. For instance, we can call <TT>RED</TT> the hypothesis in the rule below
</P><PRE>
    t1 &#X2013;&gt; t1&#X2019;  [[:RED]]
<FONT COLOR="#007FFF"><TT>    -------------- ::</TT></FONT> ctx_app_arg
    v t1 &#X2013;&gt; v t1&#X2019;
</PRE><P>
which will then generate the following Coq code:
</P><PRE>
| ctx_app_arg : forall (v t1 t1&#X2019;:term)
    (RED: reduce t1 t1&#X2019;),
    is_val_of_term v -&gt;
    reduce (t_app v t1) (t_app v t1&#X2019;).
</PRE><P>
Names of rules cannot contain spaces or other non alpha-numerical
characters, and must begin with a letter. The name annotation must at
the rightmost place on the hypothesis line, and must be enclosed
(without spaces) between the <TT>[[:</TT> and <TT>]]</TT> parentheses.</P><!--TOC subsection In-line embedded prover code in premises-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc26">6.2</A>&#XA0;&#XA0;In-line embedded prover code in premises</H3><!--SEC END --><P>
Instead of adding a formula production, one can directly embed prover
code as a premise, delimited as below by <TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT> and
<TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>. Within that, text will be echoed
directly to a prover (or given a default L<sup>A</sup>T<sub>E</sub>X typesetting) except that symbolic terms enclosed within
<TT><FONT COLOR="#007FFF">[[</FONT></TT> and <TT><FONT COLOR="#007FFF">]]</FONT></TT> will be processed as in an
<FONT COLOR="#A51815"><TT>embed</TT></FONT> section. 
</P><PRE>
  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> type_to_chunk (<FONT COLOR="#007FFF"><TT>[[</TT></FONT>typeof e1<FONT COLOR="#007FFF"><TT>]]</TT></FONT>) = Some <FONT COLOR="#007FFF"><TT>[[</TT></FONT>c<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>----------------------------------------------------------- ::</TT></FONT> Assign1
  e1=e2 . k |env   &#X2013;tau&#X2013;&gt;    lval(e1) . [__=c e2] . k |env
</PRE><!--TOC subsection User syntax-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc27">6.3</A>&#XA0;&#XA0;User syntax</H3><!--SEC END --><P>
The tool also synthesises a <TT>user_syntax</TT> grammar of all the
user syntax, for example:</P><P><IMG SRC="top2006.gif"></P><P>This is used for parsing top-level strings, for example when filtering
embedded code (&#XA7;<A HREF="#a54">8</A>).</P><!--TOC section Concrete terms and OCaml generation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc28">7</A>&#XA0;&#XA0;Concrete terms and OCaml generation</H2><!--SEC END --><P><A NAME="a57"></A>In semantic definitions, one typically never uses concrete variables,
only metavariables that range over them. 
In examples, however, one may need either a mix of concrete variables
and metavariables, or, for strictly concrete terms, to restrict to
just the former (and also to prohibit symbolic nonterminals).</P><P>Figure&#XA0;<A HREF="#a46">2</A> combines the LaTeX and proof assistant
annotations of Sections <A HREF="#a51">3</A> and <A HREF="#a58">4</A>, adding a
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">lex</FONT></TT><TT> alphanum</TT><TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>
hom
to the <FONT COLOR="#A51815"><TT>metavar</TT></FONT> declaration to specify the lexical form of
concrete variables of this sort. 
At present a <FONT COLOR="#A51815"><TT>lex</TT></FONT> homomorphism must have body either
<FONT COLOR="#A51815"><TT>Alphanum</TT></FONT> (standing for <CODE>[A-Z]([A-Z]|[a-z]|[0-9]|'|_)*</CODE>),
<FONT COLOR="#A51815"><TT>alphanum</TT></FONT> (for <CODE>([A-Z]|[a-z])([A-Z]|[a-z]|[0-9]|'|_)*</CODE>),
<FONT COLOR="#A51815"><TT>alphanum0</TT></FONT> (for <CODE>[a-z]([A-Z]|[a-z]|[0-9]|'|_)*</CODE>), or
<FONT COLOR="#A51815"><TT>numeral</TT></FONT> (for <CODE>[0-9][0-9]*</CODE>); more general regular expressions are not supported.
An identifier that can be ambiguously lexed as either a concrete or
symbolic metavariable, e.g.&#XA0;<TT>x</TT> in the scope of the above
declaration, will be taken to be symbolic. 
To restrict the parser to strictly concrete terms only, one can add a
<FONT COLOR="#A51815"><TT>:concrete:</TT></FONT> prefix, as shown in Figure&#XA0;<A HREF="#a56">10</A>.</P><P>One can also specify how concrete variables should be LaTeX&#X2019;d or
translated into a proof assistant, e.g.&#XA0;with
homomorphisms 
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">texvar</FONT></TT><TT> </TT><TT>\</TT><TT>mathrm</TT><TT>{</TT><TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>termvar</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>
and
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">isavar</FONT></TT><TT> &#X2019;&#X2019;</TT><TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>termvar</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT><TT>&#X2019;&#X2019;</TT><TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>
(and similarly <FONT COLOR="#A51815"><TT>coqvar</TT></FONT>, <FONT COLOR="#A51815"><TT>holvar</TT></FONT>, and <FONT COLOR="#A51815"><TT>ocamlvar</TT></FONT>).</P><P>Figure&#XA0;<A HREF="#a46">2</A> also specifies an OCaml representation type for
variables, with the <FONT COLOR="#A51815"><TT>metavar</TT></FONT> hom
<TT><FONT COLOR="#007FFF">{</FONT></TT><TT><FONT COLOR="#007FFF">{</FONT></TT><TT> </TT><TT><FONT COLOR="#A51815">ocaml</FONT></TT><TT> int</TT><TT><FONT COLOR="#007FFF">}</FONT></TT><TT><FONT COLOR="#007FFF">}</FONT></TT>.
Executing 
</P><PRE>
   bin/ott -i tests/test10.ott -o test10.ml  
</PRE><P>
produces the OCaml code shown in Figure&#XA0;<A HREF="#a59">9</A>, including OCaml
types to represent the abstract syntax, and auxiliary functions for
subrules and substitutions. This does not implement the semantic
rules. In some cases the various proof assistant code extraction
facilities can be used &#X2014; see Section&#XA0;<A HREF="#a22">21</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="minipage"><SPAN CLASS="textboxed">
</SPAN><PRE><SPAN CLASS="textboxed">
% all
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>metavar</TT></FONT></SPAN><SPAN CLASS="textboxed"> termvar</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>,</TT></FONT></SPAN><SPAN CLASS="textboxed"> x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed">  term variable </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> 
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>isa</TT></FONT></SPAN><SPAN CLASS="textboxed"> string</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>coq</TT></FONT></SPAN><SPAN CLASS="textboxed"> nat</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>hol</TT></FONT></SPAN><SPAN CLASS="textboxed"> string</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>coq-equality</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>ocaml</TT></FONT></SPAN><SPAN CLASS="textboxed"> int</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>lex</TT></FONT></SPAN><SPAN CLASS="textboxed"> alphanum</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>tex</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">mathit</SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">termvar</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>grammar</TT></FONT></SPAN><SPAN CLASS="textboxed">
t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;t_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">                               </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> term    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> x            </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Var                   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> variable</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed"> x . t      </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>(+</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>bind</TT></FONT></SPAN><SPAN CLASS="textboxed"> x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>in</TT></FONT></SPAN><SPAN CLASS="textboxed"> t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>+)</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> lambda  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> t t&#X2019;         </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> App                   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> app     </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> ( t )        </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>S</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Paren                 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>icho</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> 
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed"> t / x </SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed"> t&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>M</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Tsub  
                        </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>icho</TT></FONT></SPAN><SPAN CLASS="textboxed"> (tsubst_t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">x</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t&#X2019;</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed">)</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">

v </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;v_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">                               </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> value   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed"> x . t      </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam                   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> lambda  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>terminals</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;terminals_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">            </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> lambda  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>tex</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">lambda </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2013;&gt;          </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> red     </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>tex</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">longrightarrow </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>subrules</TT></FONT></SPAN><SPAN CLASS="textboxed">
  v </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>&lt;::</TT></FONT></SPAN><SPAN CLASS="textboxed"> t

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>substitutions</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>single</TT></FONT></SPAN><SPAN CLASS="textboxed"> t x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> tsubst 

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defns</TT></FONT></SPAN><SPAN CLASS="textboxed">
Jop </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X201D; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">

 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defn</TT></FONT></SPAN><SPAN CLASS="textboxed">
 t1 &#X2013;&gt; t2 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">reduce</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">&#X201D; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t1</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> reduces to </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t2</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>by</TT></FONT></SPAN><SPAN CLASS="textboxed">


</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------------------</TT></FONT></SPAN><SPAN CLASS="textboxed">  :: ax_app
    (</SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">x.t12) v2 &#X2013;&gt;  </SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed">v2/x</SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed">t12

    t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: ctx_app_fun
    t1 t &#X2013;&gt; t1&#X2019; t

    t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: ctx_app_arg
    v t1 &#X2013;&gt; v t1&#X2019;
</SPAN></PRE><SPAN CLASS="textboxed">

</SPAN></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 8: Source: <TT>test10.7.ott</TT><A NAME="a68"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="minipage"><SPAN CLASS="textboxed">
</SPAN><PRE CLASS="verbatim"><SPAN CLASS="textboxed">(* generated by Ott 0.25 from: ../tests/test10.ott ../tests/non_super_tabular.ott *)

type var = int (* term variable *)

type 
term =  (* term *)
   T_var of var (* variable *)
 | T_lam of var * term (* lambda *)
 | T_app of term * term (* app *)


(** subrules *)
let is_val_of_term (t5:term) : bool =
  match t5 with
  | (T_var x) -&gt; false
  | (T_lam (x,t)) -&gt; (true)
  | (T_app (t,t')) -&gt; false



(** substitutions *)
let rec tsubst_term (t5:term) (x5:var) (t_6:term) : term =
  match t_6 with
  | (T_var x) -&gt; (if x=x5 then t5 else (T_var x))
  | (T_lam (x,t)) -&gt; T_lam (x,(if List.mem x5 ([x]) then t else (tsubst_term t5 x5 t)))
  | (T_app (t,t')) -&gt; T_app ((tsubst_term t5 x5 t),(tsubst_term t5 x5 t'))


(** definitions *)


</SPAN></PRE><SPAN CLASS="textboxed">
</SPAN></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 9: Generated OCaml code: <TT>test10.ml</TT><A NAME="a59"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Filtering: Using Ott syntax within LaTeX, Coq, Isabelle,
HOL, or OCaml-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc29">8</A>&#XA0;&#XA0;Filtering: Using Ott syntax within LaTeX, Coq, Isabelle,
HOL, or OCaml</H2><!--SEC END --><P><A NAME="a54"></A></P><!--TOC subsection Filtering embedded code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">8.1</A>&#XA0;&#XA0;Filtering embedded code</H3><!--SEC END --><P><A NAME="a60"></A>It is possible to embed arbitrary code in
the Ott source using an <FONT COLOR="#A51815"><TT>embed</TT></FONT> block, which can contain
<FONT COLOR="#A51815"><TT>tex</TT></FONT>, 
<FONT COLOR="#A51815"><TT>coq</TT></FONT>, 
<FONT COLOR="#A51815"><TT>hol</TT></FONT>, 
<FONT COLOR="#A51815"><TT>isa</TT></FONT>, or
<FONT COLOR="#A51815"><TT>ocaml</TT></FONT> homomorphisms, the
bodies of which will appear in the respective output. 
The <CODE>embed</CODE> keyword should be on a line by itself). For
example, 
<CODE>test8.ott</CODE> contains the following to
define Coq and HOL <CODE>remove_duplicates</CODE> functions.
</P><PRE>
<FONT COLOR="#A51815"><TT>embed</TT></FONT>
<FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq</TT></FONT>
Fixpoint remove_duplicates (l:list typvar_t) : list typvar_t :=
  match l with
  | nil =&gt; nil
  | cons h t =&gt; if (list_mem eq_typvar_t h t)  then remove_duplicates t
                else cons h (remove_duplicates t)
end. <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>

<FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>hol</TT></FONT>
val _ = Define &#X2018;
  (remove_duplicates [] = []) /<TT>\</TT>
  (remove_duplicates (x::xs) = if (MEM x xs) then remove_duplicates xs 
                               else x::(remove_duplicates xs))
&#X2018;; <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
Within the body of an <FONT COLOR="#A51815"><TT>embed</TT></FONT> homomorphism, any text between 
<FONT COLOR="#007FFF"><TT>[[</TT></FONT> and <FONT COLOR="#007FFF"><TT>]]</TT></FONT> will be parsed as a symbolic term (of the
<CODE>user_syntax</CODE> grammar) and pretty printed, so one can use user
syntax within LaTeX or proof assistant code. An Isabelle example
is below, defining an Isabelle function to calculate the order of a
type with productions <CODE>unit</CODE>, <CODE>t*t'</CODE>, and <CODE>t-&gt;t'</CODE>.
</P><PRE>
<FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT>
consts
order :: "type =&gt; nat"
primrec
"order <FONT COLOR="#007FFF"><TT>[[</TT></FONT>unit<FONT COLOR="#007FFF"><TT>]]</TT></FONT> = 0"
"order <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t*t&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT> = max (order <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT>) (order <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT>)"
"order <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t-&gt;t&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT> = max (1+order <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT>) (order <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT>)"

<FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
It is often useful to define a proof assistant function, in an
<FONT COLOR="#A51815"><TT>embed</TT></FONT> section, together with a production of the <FONT COLOR="#A51815"><TT>formula</TT></FONT>
grammar with a proof assistant hom that uses that function, thereby
introducing syntax that lets the function be used in semantic rules. </P><P>Ott also permits embed blocks with <FONT COLOR="#A51815"><TT>tex-preamble</TT></FONT>,
homs, whose
contents appear in the generated L<sup>A</sup>T<sub>E</sub>X preamble.
Any definitions of L<sup>A</sup>T<sub>E</sub>X commands must appear in such a
<FONT COLOR="#A51815"><TT>tex-preamble</TT></FONT> section.
</P><!--TOC subsection Filtering files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc31">8.2</A>&#XA0;&#XA0;Filtering files</H3><!--SEC END --><P>
Similar processing can be carried out on separate files, using the
command-line options <CODE>tex_filter</CODE>, <CODE>isa_filter</CODE>, etc.
Each of these takes two arguments, a source filename and a destination
filename. In processing the source file, 
any text between 
<FONT COLOR="#007FFF"><TT>[[</TT></FONT> and <FONT COLOR="#007FFF"><TT>]]</TT></FONT> will be parsed as a symbolic term (of the
<CODE>user_syntax</CODE> grammar) and pretty printed in the appropriate
style. All other text is simply echoed.
</P><P>Typical usage for LaTeX would be something like this (from the <CODE>Makefile</CODE>
used to produce this document):
</P><PRE CLASS="verbatim">test7.tex: ../src/ott ../tests/test7.ott ../tests/test7tt.mng
         cd ../src; make tmp_test7_clean.ott
         ../src/ott                                        \
                -i ../src/tmp_test7_clean.ott              \
                -o test7.tex                               \
                -tex_show_meta false                       \
                -tex_wrap false                            \
                -tex_name_prefix testSeven                 \
                -tex_filter ../tests/test7tt.mng test7tt.tex 
</PRE><P>The <CODE>-tex_wrap false</CODE> turns off output of the default LaTeX
document preamble, so the generated file <CODE>test7.tex</CODE> just contains
LaTeX definitions. 
The <CODE>-tex_name_prefix testSeven</CODE> sets a prefix for the generated
LaTeX commands
(so the LaTeX definitions from multiple Ott source files can be
included in a single LaTeX document).
The <CODE>-tex_filter</CODE> argument takes two
filenames, a source and a destination. It filters the source file,
(roughly) replacing any string found within <CODE>[[</CODE> <CODE>]]</CODE> by
the tex pretty-print of its parse. This parsing is done w.r.t.&#XA0;the generated nonterminal 
<CODE>user_syntax</CODE> which is a union of all the user&#X2019;s grammar. </P><P>At present munged strings are not automatically
put within <CODE>$</CODE> <CODE>$</CODE>, and there is no analogue of the
<CODE>&lt;[</CODE> <CODE>]&gt;</CODE> of our previous munger. </P><P>The lexing 
turns any sequence of <CODE>[</CODE> (resp. of <CODE>]</CODE>) of
length <I>n</I>+1 for <I>n</I>&gt;2 into a literal sequence of length <I>n</I>.</P><P>Figures&#XA0;<A HREF="#a56">10</A> and <A HREF="#a55">11</A> show a source file (<TT>test7tt.mng</TT>) that uses terms of the F<SUB>&lt;:</SUB>
definition of <TT>test7.ott</TT>, and the result of filtering it.</P><P>Similar filtering can be performed on Coq, Isabelle, HOL, and OCaml files.</P><P>To filter files with respect to a relatively stable
system definition, without having to re-process the Ott source files of
that system definition each time, there are command-line options
</P><PRE CLASS="verbatim">  -writesys &lt;filename&gt;                Output system definition
  -readsys &lt;filename&gt;                 Input system definition
</PRE><P>to first write the system definition (generated from some source files) to a file, and
then to read one back in (instead of re-reading the Ott source files). 
The saved system definitions are in an internal format, produced using
the OCaml marshaller, and contain OCaml closures. They therefore will
not be compatible between different Ott versions. They may also be
quite large. </P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<PRE>
We can TeX-typeset symbolic terms of the language, e.g.
<TT>\</TT>[ <FONT COLOR="#007FFF"><TT>[[</TT></FONT> (<TT>\</TT>X&lt;:Top. <TT>\</TT>x:X.x) [Top-&gt;Top] <FONT COLOR="#007FFF"><TT>]]</TT></FONT><TT>\</TT>]
and concrete terms
<TT>\</TT>[ <FONT COLOR="#007FFF"><TT>[[</TT></FONT> <FONT COLOR="#A51815"><TT>:concrete:</TT></FONT> <TT>\</TT>Z1&lt;:Top. <TT>\</TT>x:Z1.x <FONT COLOR="#007FFF"><TT>]]</TT></FONT><TT>\</TT>]
and similarly judgements etc, e.g.
<TT>\</TT>[ <FONT COLOR="#007FFF"><TT>[[</TT></FONT>G |- t : T <FONT COLOR="#007FFF"><TT>]]</TT></FONT> <TT>\</TT>]
   
Here is an extract of the syntax:

<TT>\</TT>testSevengrammartabular<TT>{</TT><TT>\</TT>testSevent<TT>\</TT>testSevenafterlastrule<TT>}</TT>

and a single semantic rule:

<TT>\</TT>[<TT>\</TT>testSevendruletinXXTwo<TT>{</TT><TT>}</TT><TT>\</TT>]

and a judgement definition:

<TT>\</TT>testSevendefnSA

One can also include a &#X2018;defns&#X2019; collection of judgements, or the complete definition.
% <TT>\</TT>section<TT>{</TT>Full Definition<TT>}</TT>
% <TT>\</TT>testSevenmetavars<TT>\</TT><TT>\</TT>[0pt]
% <TT>\</TT>testSevengrammar<TT>\</TT><TT>\</TT>[0pt]
% <TT>\</TT>testSevendefnss
%
% <TT>\</TT>testSevenall


</PRE>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 10: F<SUB>&lt;:</SUB> Extracts: LaTeX source file to be filtered (<TT>test7tt.mng</TT>)<A NAME="a56"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<IMG SRC="top2007.gif"><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 11: F<SUB>&lt;:</SUB> Extracts: the filtered output (<TT>test7tt.tex</TT>)<A NAME="a55"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Binding specifications-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc32">9</A>&#XA0;&#XA0;Binding specifications</H2><!--SEC END --><P><A NAME="a62"></A></P><P>Our first example involved a production with a single binder:

</P><P><IMG SRC="top2008.gif"></P><P>specified by the source shown in Figure&#XA0;<A HREF="#a47">4</A>:
</P><PRE>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT> x . t      <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam     <FONT COLOR="#007FFF"><TT>(+</TT></FONT> <FONT COLOR="#A51815"><TT>bind</TT></FONT> x <FONT COLOR="#A51815"><TT>in</TT></FONT> t <FONT COLOR="#007FFF"><TT>+)</TT></FONT>
</PRE><P>
in which a single variable binds in a single subterm.
Realistic programming languages often have much more complex binding
structures, e.g.&#XA0;structured patterns, multiple mutually recursive <TT>let</TT> definitions,
comprehensions, or-patterns, and dependent record patterns.</P><P>Ott has a flexible metalanguage for specifying binding structures,
expressive enough to cover these.
It comprises two forms of annotation on productions.
The first, 

<IMG SRC="top2009.gif">lets one specify that variables bind in nonterminals of the
production, as in the <TT>Lam</TT> production above.
Here 

<IMG SRC="top2010.gif">is a <EM>metavariable set expression</EM>,
e.g.&#XA0;in that lambda production just the singleton
metavariable 

<IMG SRC="top2011.gif">of the production.
A variable can bind in multiple nonterminals, as in the example of
a simple recursive <TT>let</TT> below.</P><P><IMG SRC="top2012.gif"></P><P>More complex examples require one to collect together sets of
variables. For example, the grammar below (shown in Ott source and the
generated LaTeX) has structured patterns,
with a 
<IMG SRC="top2013.gif">production in which all the binders of the pattern 

<IMG SRC="top2014.gif">bind in the continuation 

<IMG SRC="top2015.gif"></P><PRE>
t <FONT COLOR="#007FFF"><TT>::</TT></FONT> E_ <FONT COLOR="#007FFF"><TT>::=</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> x                        <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> ident
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> ( t1 , t2 )              <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> pair
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> let p = t in t&#X2019;          <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> letrec      <FONT COLOR="#007FFF"><TT>(+</TT></FONT> <FONT COLOR="#A51815"><TT>bind</TT></FONT> binders<FONT COLOR="#007FFF"><TT>(</TT></FONT>p<FONT COLOR="#007FFF"><TT>)</TT></FONT> <FONT COLOR="#A51815"><TT>in</TT></FONT> t&#X2019; <FONT COLOR="#007FFF"><TT>+)</TT></FONT>


p <FONT COLOR="#007FFF"><TT>::</TT></FONT> P_ <FONT COLOR="#007FFF"><TT>::=</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> _                        <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> wildcard    <FONT COLOR="#007FFF"><TT>(+</TT></FONT> binders <FONT COLOR="#007FFF"><TT>=</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>+)</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> x                        <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> ident       <FONT COLOR="#007FFF"><TT>(+</TT></FONT> binders <FONT COLOR="#007FFF"><TT>=</TT></FONT> x <FONT COLOR="#007FFF"><TT>+)</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> ( p1 , p2 )              <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> pair        <FONT COLOR="#007FFF"><TT>(+</TT></FONT> binders <FONT COLOR="#007FFF"><TT>=</TT></FONT> binders<FONT COLOR="#007FFF"><TT>(</TT></FONT>p1<FONT COLOR="#007FFF"><TT>)</TT></FONT> <FONT COLOR="#A51815"><TT>union</TT></FONT> binders<FONT COLOR="#007FFF"><TT>(</TT></FONT>p2<FONT COLOR="#007FFF"><TT>)</TT></FONT> <FONT COLOR="#007FFF"><TT>+)</TT></FONT>
</PRE><P><IMG SRC="top2016.gif"></P><P>This is expressed with the second form of annotation: user-defined
<EM>auxiliary functions</EM> such as the 
binders above. This is an auxiliary function defined over the

<IMG SRC="top2017.gif">grammar that identifies a set of variables to be
used in the <FONT COLOR=purple>bind</FONT> annotation on the 
<IMG SRC="top2018.gif">production. There can be any number of such auxiliary functions;
binders is not a distinguished keyword.</P><P>The syntax of a precise fragment of the binding metalanguage is given in
Fig.&#XA0;<A HREF="#a13">12</A>,

</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<IMG SRC="top2019.gif"><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 12: Mini-Ott in Ott: the binding specification metalanguage<A NAME="a13"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>where we have used Ott to define part of the Ott
metalanguage. A simple type system (not shown) enforces sanity properties,
e.g.&#XA0;that each auxiliary function is only applied to nonterminals that
it is defined over, and that metavariable set expressions are
well-sorted.</P><P>Further to that fragment, the tool supports binding for the list forms
of &#XA7;<A HREF="#a61">12</A>. 
Metavariable set expressions can include lists of metavariables
and auxiliary functions applied to lists of nonterminals, e.g.&#XA0;as in
the record patterns below.
</P><P><IMG SRC="top2020.gif"></P><P>This suffices to express the binding structure of almost all the
natural examples we have come across, including definitions of
mutually recursive functions with multiple clauses for each, Join
calculus definitions&#XA0;[<A HREF="#FGLMR96">FGL+96</A>], dependent record patterns, and many others.</P><!--TOC section Generating substitution and free variable functions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc33">10</A>&#XA0;&#XA0;Generating substitution and free variable functions</H2><!--SEC END --><P><A NAME="a67"></A>The tool can generate Isabelle/Coq/HOL/OCaml code for both single and multiple
substitution functions. For example, the ML polymorphism Ott source
of <TT>test8.ott</TT> includes the following.
</P><PRE>
  <FONT COLOR="#A51815"><TT>substitutions</TT></FONT>
    <FONT COLOR="#A51815"><TT>single</TT></FONT>   expr value_name <FONT COLOR="#007FFF"><TT>::</TT></FONT> subst  
    <FONT COLOR="#A51815"><TT>multiple</TT></FONT> typexpr typvar  <FONT COLOR="#007FFF"><TT>::</TT></FONT> tsubst 
</PRE><P>
This causes the generation of two families of substitution
functions, one replacing a single <CODE>value_name</CODE> by a <CODE>expr</CODE>,
the other replacing multiple <CODE>typvar</CODE>s by <CODE>typexpr</CODE>s. </P><P>Each family contains a function for each datatype for which it is
required, so in that example there are functions
<CODE>subst_expr</CODE> for the first and <CODE>tsubst_typexpr</CODE>,
<CODE>tsubst_typscheme</CODE> and <CODE>tsubst_G</CODE> for the second. </P><P>The functions for substitutions declared by
</P><PRE>
  <FONT COLOR="#A51815"><TT>substitutions</TT></FONT>
    <FONT COLOR="#A51815"><TT>single</TT></FONT>   this that <FONT COLOR="#007FFF"><TT>::</TT></FONT> name1 
    <FONT COLOR="#A51815"><TT>multiple</TT></FONT> this that <FONT COLOR="#007FFF"><TT>::</TT></FONT> name2 
</PRE><P>
replaces terms of productions consisting just of a single <CODE>that</CODE> by a
<CODE>this</CODE>.
Here <CODE>this</CODE> must be a nonterminal root, while <CODE>that</CODE> can be
either a metavariable root or a nonterminal root (the latter
possibility allows substitution for compound identifiers, though it is
not clear that this is generally useful enough to be included). 
Substitution functions are generated for each member of each (mutually recursive)
block of grammar rules which either contain such a production or (indirectly)
refer to one that does. </P><P>At present multiple substitutions are represented by Isabelle/Coq/HOL/OCaml
lists, so for the example above we have Isabelle
</P><PRE CLASS="verbatim">  tsubst_typexpr :: "(typvar*typexpr) list =&gt; typexpr =&gt; typexpr"
  tsubst_typscheme :: "(typvar*typexpr) list =&gt; typscheme =&gt; typscheme"
  tsubst_G :: "(typvar*typexpr) list =&gt; G =&gt; G"
</PRE><P>The generated functions do not substitute bound things, and recursive
calls under binders are filtered to remove the bound things.</P><P>Similarly, the tool can generate Isabelle/Coq/HOL/OCaml to calculate the free
variables of terms. For example, the ML polymorphism Ott source
of <TT>test8.ott</TT> includes the following.
</P><PRE>
  <FONT COLOR="#A51815"><TT>freevars</TT></FONT>
    typexpr typvar <FONT COLOR="#007FFF"><TT>::</TT></FONT> ftv
</PRE><P>
This causes Isabelle functions as below to be generated, calculating
the free <TT>typvar</TT>s that occur in singleton productions in the
<TT>typexpr</TT> grammar, within terms of all types.
</P><PRE CLASS="verbatim">  ftv_typexpr :: "typexpr =&gt; typvar list"
  ftv_typscheme :: "typscheme =&gt; typvar list"
  ftv_G :: "G =&gt; typvar list"
</PRE><!--TOC section Locally-nameless representation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc34">11</A>&#XA0;&#XA0;Locally-nameless representation</H2><!--SEC END --><P>The Coq backend of Ott includes experimental support for a
locally-nameless representation (and co-finite quantification). </P><P>The user must specify which metavariables require a locally-nameless
representation via the <TT><FONT COLOR="#A51815">repr-locally-nameless</FONT></TT> hom,
e.g.:</P><PRE>
<FONT COLOR="#A51815"><TT>metavar</TT></FONT> x <FONT COLOR="#007FFF"><TT>::=</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>repr-locally-nameless</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT>  term variable  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
</PRE><P>As usual, metavariables can be bound in productions, using the
bindspec language, as in the <TT>lam</TT> production below:
</P><PRE>
<FONT COLOR="#A51815"><TT>grammar</TT></FONT>
  t <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;t_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>                                         <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> term <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> x                   <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> Var                     <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> variable <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>         
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT> x . t             <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam  <FONT COLOR="#007FFF"><TT>(+</TT></FONT> <FONT COLOR="#A51815"><TT>bind</TT></FONT> x <FONT COLOR="#A51815"><TT>in</TT></FONT> t <FONT COLOR="#007FFF"><TT>+)</TT></FONT>  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> abstraction <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>      
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> t t&#X2019;                <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> App                     <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> application <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>      
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> ( t )               <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>S</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> paren   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>{</TT> t / x <TT>}</TT> t&#X2019;        <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> tsub    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq</TT></FONT> (t_subst_t <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT><FONT COLOR="#007FFF"><TT>[[</TT></FONT>x  t&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT>) <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>This definition gives rise to the datatype term below (here with option <TT>-coq_names_in_rules false</TT>):
</P><PRE>
Inductive term : Set := 
| term_var_b : nat -&gt; term 
| term_var_f : var -&gt; term 
| term_lam : term -&gt; term 
| term_app : term -&gt; term -&gt; term.
</PRE><P>Remarks:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Productions containing metavariables susceptible to be bound
(e.g., <TT>term_var</TT>) give rise to two distinct constructors, one
(<TT>term_var_b</TT>) for de Bruijn indices to be used when the metavariable
is bound, one (<TT>term_var_f</TT>) for "free" variables. The type <TT>var</TT>,
together with decidable equality and several useful lemmas and
functions, is defined in the Metatheory library.<P>In the current implementation, metavariables susceptible to be bound
in a symbolic term (eg. the <TT>x</TT> in the <TT>term_var</TT>
production) must be the only element of the production.</P></LI><LI CLASS="li-enumerate">Binder metavariables are erased from productions
(eg. <TT>term_lam</TT>), as in de Bruijn representation.
</LI></OL><P>Ott automatically generates the appropriate <TT>open</TT> functions
and <TT>lc</TT> predicates to test if terms are locally-closed. The
other support functions for substitutions and free-variables
(<TT>subst</TT> and <TT>fv</TT>) are generated once the user declares
the relevant substitutions and freevars sections.</P><P>Ott automatically compiles the symbolic terms that appear in rule
definitions into the appropriate terms in locally-nameless style. For
instance, the typing rule for the simply-typed lambda-calculus:</P><PRE>
    E,x:S |- t : T
<FONT COLOR="#007FFF"><TT>    ------------------</TT></FONT> :: lambda
    E |- <TT>\</TT>x.t : S-&gt;T
</PRE><P>
is compiled into its locally-nameless representation:
</P><PRE>
Inductive typing : env -&gt; term -&gt; type -&gt; Prop := (* defn typing *) 
| ... 
| typing_lambda : forall (L:vars) (E:env) (t:term) (S T:type), 
   (forall x, x <TT>\</TT>notin L -&gt; typing (E &amp; x ~ S) (open_term_wrt_term t (term_var_f x)) T) -&gt; 
   typing E (term_lam t) (type_arrow S T).
</PRE><P>For that, Ott follows the algorithm below. For each rule,
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
for each nonterminal that appears in the rule, compute the
maximal set of binders under which it appears: for example, in the
rule lambda above, the maximal set of binders for the nonterminal <TT>t</TT>
is the singleton <TT>x</TT>, and it is empty for all the other nonterminals;
</LI><LI CLASS="li-enumerate">for each pair nonterminal / maximal binder set collected in
phase 1., go over all the occurrences of the nonterminal in the rule
and open them with respect to all the variables in the maximal
binding set except those under which this particular occurrence is
bound. In the example, this amounts to opening the occurrence of <TT>t</TT>
in the premise with respect to the metavariable <TT>x</TT>;
</LI><LI CLASS="li-enumerate">quantify using cofinite-quantification each metavariable that
has been used to open a nonterminal;
</LI><LI CLASS="li-enumerate">add hypothesis about local-closure to guarantee the invariant
that if a derivation holds, then the top-level terms involved are
locally-closed.
</LI></OL><P>
In some cases the user may want a finer control on which nonterminals
are opened and with respect to which metavariables. Consider for
instance the CBV beta-reduction rule:
</P><PRE>
<FONT COLOR="#007FFF"><TT>    --------------------------</TT></FONT>  :: ax_app
    (<TT>\</TT>x.t1) v2 &#X2013;&gt;  <TT>{</TT>v2/x<TT>}</TT>t1
</PRE><P>
A naive application of the algorithm described above would open the
right hand side occurrence of <TT>t1</TT> with respect to a
cofinitely-quantified <TT>x</TT>. Substitution should then be used to replace
the occurrences of <TT>x</TT> with <TT>v2</TT>, resulting in the awkward term
</P><PRE>
reduce (term_app (term_lam t1) v2) (subst_term v2 x (open_term_wrt_term t1 (term_var_f x)))
</PRE><P>Instead, an idiomatic translation of CBV beta-reduction rule would
directly rely on the open function to substitute <TT>v2</TT> for the
bound occurrences of <TT>x</TT> in <TT>t1</TT>, as in:
</P><PRE>
reduce (term_app (term_lam t1) v2) (open_term_wrt_term t1 v2)
</PRE><P>A special syntax for production homomorphisms allow the user to specify this translation:
</P><PRE>
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>{</TT> t / x <TT>}</TT> t&#X2019;        <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> tsub    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq</TT></FONT> (t_subst_t <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT><FONT COLOR="#007FFF"><TT>[[</TT></FONT>x t&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT>) <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
In the homomorphism the nonterminal <TT>t&#X2019;</TT> is referred to with
<TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>x t&#X2019;</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT> instead of the usual
<TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>t&#X2019;</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT>: the prefixed <TT>x</TT> specifies
that occurrences of <TT>t&#X2019;</TT> should not be opened with respect to
the metavariable <TT>x</TT>. If this homomorphism is specified, then
the translation of the <TT>ax_app</TT> rule is exactly idiomatic Coq
shown above.</P><P><I>Current limitations: support for single binders only, no auxfn, Coq only.</I></P><P><I>Disclaimer: to compile rule definitions, Ott applies blindly the algorithm described above. Although in most of the cases, this generates a correct and idiomatic representation of the language, some language constructs might not be faithfully translated. Please, let us know if you find one of these cases.
</I></P><P>If Ott is invoked with the <TT>-coq_lngen</TT> option, then the
generated locally-nameless Coq code is compatible with Aydemir&#X2019;s
<I>lngen</I> tool (<A HREF="http://www.cis.upenn.edu/&#XA0;baydemir/papers/lngen/"><TT>http://www.cis.upenn.edu/&#XA0;baydemir/papers/lngen/</TT></A>).</P><!--TOC section List forms-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc35">12</A>&#XA0;&#XA0;List forms</H2><!--SEC END --><P><A NAME="a61"></A>Ott has direct support for lists, both as <EM>dot forms</EM> such as 

<IMG SRC="top2021.gif">and as <EM>list comprehensions</EM> such as 

<IMG SRC="top2022.gif">.
Figure&#XA0;<A HREF="#a63">13</A> shows an example semantic rule taken from our OCaml
fragment semantics, as both the generated LaTeX and its Ott
source, that involves several dot forms.
Other types commonly used in semantics, e.g.&#XA0;finite maps or sets, can
often be described with this list syntax in conjunction with type and
metaproduction homs to specify the proof assistant representation.
When using list forms, one usually also wants to add a list-of-formula
production to the <FONT COLOR="#A51815"><TT>formula</TT></FONT> grammar, e.g. (as in
<CODE>test17.10.ott</CODE>):
</P><PRE>
  <FONT COLOR="#A51815"><TT>formula</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> formula_ <FONT COLOR="#007FFF"><TT>::=</TT></FONT>  
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  judgement                       <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> judgement
   <FONT COLOR="#007FFF"><TT>|</TT></FONT>  formula1 <FONT COLOR="#007FFF"><TT>..</TT></FONT> formulan            <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> dots
</PRE><P>
The proof assistant code generation for such a production (which must
be named <CODE>formula_dots</CODE>) is special-cased to a list conjunction.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<IMG SRC="top2023.gif"><PRE>
 E |- e1 : t1 ... E |- en : tn
 E |- field_name1 : t-&gt;t1 ... E |- field_namen : t-&gt;tn
 t = (t1&#X2019;, ..., tl&#X2019;) typeconstr_name
 E |- typeconstr_name gives typeconstr_name:kind <TT>{</TT>field_name1&#X2019;; ...; field_namem&#X2019;<TT>}</TT>
 field_name1...field_namen PERMUTES field_name1&#X2019;...field_namem&#X2019;
 length (e1)...(en)&gt;=1
 &#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2014;&#X2013; :: record_constr
 E |- <TT>{</TT>field_name1=e1; ...; field_namen=en<TT>}</TT> : t
</PRE><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 13: A sample OCaml semantic rule, in LaTeX and Ott
source forms<A NAME="a63"></A></TD></TR>
</TABLE></DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection List dot forms-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">12.1</A>&#XA0;&#XA0;List dot forms</H3><!--SEC END --><P><A NAME="a66"></A>Example productions for 
record types, record terms, and record
patterns are shown below, in both Ott source and LaTeX, taken
from our F<SUB>&lt;:</SUB> example.
</P><PRE>
T<FONT COLOR="#007FFF"><TT>,</TT></FONT> S<FONT COLOR="#007FFF"><TT>,</TT></FONT> U <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;T_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>                                               <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> type  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>{</TT> l1 : T1 , <FONT COLOR="#007FFF"><TT>..</TT></FONT> , ln : Tn <TT>}</TT>      <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec                       <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> record <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>           

t <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;t_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>                                                     <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT>  term  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>{</TT> l1 = t1 ,  <FONT COLOR="#007FFF"><TT>..</TT></FONT> , ln = tn <TT>}</TT>     <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec                       <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> record <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> let p = t in t&#X2019;                 <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Let <FONT COLOR="#007FFF"><TT>(+</TT></FONT> <FONT COLOR="#A51815"><TT>bind</TT></FONT> b<FONT COLOR="#007FFF"><TT>(</TT></FONT>p<FONT COLOR="#007FFF"><TT>)</TT></FONT> <FONT COLOR="#A51815"><TT>in</TT></FONT> t&#X2019; <FONT COLOR="#007FFF"><TT>+)</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> pattern binding<FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>

p <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;P_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>                                                     <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT>  pattern <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> x : T                           <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Var <FONT COLOR="#007FFF"><TT>(+</TT></FONT> b <FONT COLOR="#007FFF"><TT>=</TT></FONT> x  <FONT COLOR="#007FFF"><TT>+)</TT></FONT>          <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> variable pattern <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>{</TT> l1 = p1 , <FONT COLOR="#007FFF"><TT>..</TT></FONT> , ln = pn <TT>}</TT>      <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec <FONT COLOR="#007FFF"><TT>(+</TT></FONT> b <FONT COLOR="#007FFF"><TT>=</TT></FONT> b<FONT COLOR="#007FFF"><TT>(</TT></FONT>p1 <FONT COLOR="#007FFF"><TT>..</TT></FONT> pn<FONT COLOR="#007FFF"><TT>)</TT></FONT> <FONT COLOR="#007FFF"><TT>+)</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT>  record pattern  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>

</PRE><P>
<IMG SRC="top2024.gif"></P><P>Dot forms can be used in symbolic terms in semantic rules:</P><P>
<IMG SRC="top2025.gif"></P><P>Individually indexed projections from dot forms can be mentioned, eg
the <I>l</I><SUB><I>j</I></SUB> below:</P><P>
<IMG SRC="top2026.gif"></P><P>Symbolic terms can also include concatenations of two dot forms with a
singleton in between:</P><P>
<IMG SRC="top2027.gif"></P><P>Multiple dot forms within the same semantic rule can share bounds (e.g.&#XA0;1..<I>m</I>):</P><P>
<IMG SRC="top2028.gif"></P><P>In more detail, productions can have dot tokens interspersed between the elements. 
Dot tokens consist of two, three or four consecutive dots (<FONT COLOR="#007FFF"><TT>..</TT></FONT>,
<FONT COLOR="#007FFF"><TT>...</TT></FONT>, or <FONT COLOR="#007FFF"><TT>....</TT></FONT>), indicating lists with minimum lengths 0,
1, and 2 respectively (these length minimums are respected
only when parsing concrete lists; they are not present in Isabelle/Coq/HOL
output). 
The tool identifies the maximal sequence of elements on either side of
the dots that are identical modulo anti-unification of some
index. Optionally, there may also be a single terminal on either side
of the dot token, separating instances of the repeated unit.
For example, in the <TT>test7.ott</TT> production
</P><PRE>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>{</TT> l1 = t1 ,  <FONT COLOR="#007FFF"><TT>..</TT></FONT> , ln = tn <TT>}</TT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec                     
</PRE><P>
there is such a terminal (the &#X2018;<CODE>,</CODE>&#X2019;). The tool identifies
that <CODE>l1 = t1</CODE> and <CODE>ln = tn</CODE> can be anti-unified as 
(roughly) <CODE>l_ = t_</CODE>, taking <CODE>_</CODE> to be the bounds <CODE>1</CODE> and <CODE>n</CODE>.
A single production may contain multiple dot forms, but they must not overlap;
nested dot forms (including those with multiple changing indices) are not currently
supported. </P><P>Homomorphisms and binding specifications are generalised to match: an <CODE>mse</CODE> can
involve a dot form of metavariables; 
a dot form of nonterminals; or an auxiliary function applied to a dot
form
of nonterminals (e.g.&#XA0;the
b(<I><I>p</I></I><SUB>1</SUB>..<I><I>p</I></I><SUB><I><I>n</I></I></SUB>) above).
Dot forms on the right of a <FONT COLOR="#A51815"><TT>bind</TT></FONT> are not currently supported.</P><P>LaTeX homomorphisms should not refer to dot forms, as either an error
or bad output will be generated. (For LaTeX, there should really be
some means to specify
a homomorphism for the repeated expression, and also data on how any
list separators should be typeset. This would require more
special-case treatment, which is not currently supported.)</P><!--TOC subsection List comprehension forms-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc37">12.2</A>&#XA0;&#XA0;List comprehension forms</H3><!--SEC END --><P><A NAME="a44"></A>Lists can also be expressed as explicit list comprehensions, 
for more concise typesetting.
Three different styles are supported, with no bounds, an upper bound,
or a lower and upper bound. For example, in a symbolic
term, instead of the dot form 
</P><PRE>
  G |- t1:T1  <FONT COLOR="#007FFF"><TT>..</TT></FONT>  G |- tn:Tn
 </PRE><P>

one can write any of the following
</P><PRE>
   <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> G |- ti:Ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> i           <FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT>
   <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> G |- ti:Ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> i <FONT COLOR="#007FFF"><TT>IN</TT></FONT> n      <FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT>
   <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> G |- ti:Ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> i <FONT COLOR="#007FFF"><TT>IN</TT></FONT> 1 <FONT COLOR="#007FFF"><TT>..</TT></FONT> n <FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT>
 </PRE><P>

Similar comprehensions can be used in productions, for example lines
2&#X2013;4 below. In addition, comprehensions in productions can specify a
terminal to be used as a separator in concrete lists, as in lines 5&#X2013;7 below.
(These examples are taken from <CODE>test17.10.ott</CODE>.)
</P><PRE>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT>  l1 = t1 ,  <FONT COLOR="#007FFF"><TT>..</TT></FONT> , ln = tn            <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec              <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> dots <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT>  <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> li = ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> i           <FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT>       <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec_comp_none    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> comp <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT>  <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> li = ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> i <FONT COLOR="#007FFF"><TT>IN</TT></FONT> n      <FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT>       <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec_comp_u_none  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> compu <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
  <FONT COLOR="#007FFF"><TT>|</TT></FONT>  <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> li = ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> i <FONT COLOR="#007FFF"><TT>IN</TT></FONT> 1 <FONT COLOR="#007FFF"><TT>..</TT></FONT> n <FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT>       <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec_comp_lu_none <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> complu <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>  
  <FONT COLOR="#007FFF"><TT>|</TT></FONT>  <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> li = ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> , <FONT COLOR="#007FFF"><TT>//</TT></FONT> i           <FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec_comp_some    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> comp with terminal <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT>  <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> li = ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> , <FONT COLOR="#007FFF"><TT>//</TT></FONT> i <FONT COLOR="#007FFF"><TT>IN</TT></FONT> n      <FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec_comp_u_some  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> compu with terminal <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
  <FONT COLOR="#007FFF"><TT>|</TT></FONT>  <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> li = ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> , <FONT COLOR="#007FFF"><TT>//</TT></FONT> i <FONT COLOR="#007FFF"><TT>IN</TT></FONT> 1 <FONT COLOR="#007FFF"><TT>..</TT></FONT> n <FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Rec_comp_lu_some <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> complu with terminal <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>  
 </PRE><P>

In Coq, HOL or Isabelle output, list dot forms and the
various list comprehension forms are treated almost identically.
In LaTeX output, comprension forms are default-typeset with overbars. 
For example, the rules below
</P><PRE>
 G|- t:l1:T1,<FONT COLOR="#007FFF"><TT>..</TT></FONT>,ln:Tn
<FONT COLOR="#007FFF"><TT> ----------------------- :: </TT></FONT>Proj_dotform
 G|- t.lj : Tj

 G|- t:  <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> li:Ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> i<FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT> 
<FONT COLOR="#007FFF"><TT> ---------------------------------- ::</TT></FONT> Proj_comp
 G|- t.lj : Tj

 G|- t:  <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> li:Ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> i <FONT COLOR="#007FFF"><TT>IN</TT></FONT> n<FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT> 
<FONT COLOR="#007FFF"><TT> ---------------------------------- ::</TT></FONT> Proj_comp_u
 G|- t.lj : Tj

 G|- t:  <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> li:Ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> i <FONT COLOR="#007FFF"><TT>IN</TT></FONT> 1<FONT COLOR="#007FFF"><TT>..</TT></FONT>n<FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT> 
<FONT COLOR="#007FFF"><TT> ---------------------------------- ::</TT></FONT> Proj_comp_lu
 G|- t.lj : Tj
 </PRE><P>

are typeset as follows.</P><P>
<IMG SRC="top2029.gif"></P><P>Upper bounds of the form <I>n</I>&#X2212;1 are also permitted, e.g. with
</P><PRE>
 G|- t:l0:T0,<FONT COLOR="#007FFF"><TT>..</TT></FONT>,ln-1:Tn-1
<FONT COLOR="#007FFF"><TT> ----------------------- ::</TT></FONT> Proj_dotform_minus
 G|- t.lj : Tj

 G|- t:  <FONT COLOR="#007FFF"><TT>&lt;/</TT></FONT> li:Ti <FONT COLOR="#007FFF"><TT>//</TT></FONT> i <FONT COLOR="#007FFF"><TT>IN</TT></FONT> 0<FONT COLOR="#007FFF"><TT>..</TT></FONT>n-1<FONT COLOR="#007FFF"><TT>/&gt;</TT></FONT> 
<FONT COLOR="#007FFF"><TT> ---------------------------------- ::</TT></FONT> Proj_comp_lu_minus
 G|- t.lj : Tj
 </PRE><P>

typeset as below. More complex arithmetic expressions are not
currently supported.</P><P>
<IMG SRC="top2030.gif"></P><P>A list form used in a symbolic term does not have to be in the same
style as that in the corresponding production. 
However, if a metavariable or nonterminal occurs in multiple different
list forms in the same inference rule, they must all be in the same style and
with the same bounds. Moreover, in a production, a list form in a bindspec or
homomorphism must be in the same style and with the same bounds as the
corresponding list form in the elements of the production. </P><P>The comprehension form without an upper bound, 
e.g.&#XA0;<TT><FONT COLOR="#007FFF">&lt;/</FONT></TT><TT> G |- ti:Ti </TT><TT><FONT COLOR="#007FFF">//</FONT></TT><TT> i </TT><TT><FONT COLOR="#007FFF">/&gt;</FONT></TT>, 
typeset as 
<IMG SRC="top2031.gif">is not standard
notation, but is often very useful. Many semantic rules involve lists
of matched length, e.g.&#XA0;of the 
<IMG SRC="top2032.gif">and
<IMG SRC="top2033.gif">here, but do not need to introduce an
identifier for that length; omitting it keeps them concise.</P><P>The default visual style for typesetting list comprehensions can be
overridden by redefining the LaTeX commands <CODE>\ottcomp</CODE>,
<CODE>\ottcompu</CODE>, and <CODE>\ottcomplu</CODE> in an <FONT COLOR="#A51815"><TT>embed</TT></FONT> section, as
in Section&#XA0;<A HREF="#a64">4.3</A>.</P><P>In some cases one could make the typeset notation even less noisy, by
either omitting the superscript <I>i</I> or omitting both the superscript <I>i</I> and
the subscript <I>i</I>&#X2019;s on <I>t</I> and <I>T</I>. The first is unambiguous if there
is at most one index on each element in the comprehension; the second
if all the elements are indexed by the same thing (not the case for
this example, but common for comprehensions of single elements,
e.g. <CODE>&lt;&lt; Ti // i&gt;&gt;</CODE> for <SPAN style="text-decoration:overline"><I>T</I></SPAN>). It is arguable that that
should be automated in future Ott releases, though it would bring the typeset and ASCII
versions out of step.</P><P>List comprehension forms can also be used in bindspecs and in
homomorphisms. </P><!--TOC subsection Proof assistant code for list forms-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc38">12.3</A>&#XA0;&#XA0;Proof assistant code for list forms</H3><!--SEC END --><P><A NAME="a65"></A></P><!--TOC subsubsection Types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc39">12.3.1</A>&#XA0;&#XA0;Types</H4><!--SEC END --><P>
We have to choose proof assistant representations for productions involving list
forms. For example, for a language with records one might write 
</P><PRE>
  <FONT COLOR="#A51815"><TT>metavar</TT></FONT> label<FONT COLOR="#007FFF"><TT>,</TT></FONT> l <FONT COLOR="#007FFF"><TT>::=</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>hol</TT></FONT> string <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq</TT></FONT> nat <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#A51815"><TT>indexvar</TT></FONT> index<FONT COLOR="#007FFF"><TT>,</TT></FONT> n <FONT COLOR="#007FFF"><TT>::=</TT></FONT>  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>hol</TT></FONT> num <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq</TT></FONT> nat <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
  <FONT COLOR="#A51815"><TT>grammar</TT></FONT>
  term<FONT COLOR="#007FFF"><TT>,</TT></FONT> t <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;t_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>{</TT> l1 = t1 ,  <FONT COLOR="#007FFF"><TT>..</TT></FONT> , ln = tn <TT>}</TT>      <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> record
</PRE><P>

In HOL and Isabelle we represent these simply with contructors whose
argument types involve proof-assistant native list types, e.g.
the HOL list of pairs of a <CODE>label</CODE> and a <CODE>t</CODE>:
</P><PRE CLASS="verbatim">  val _ = Hol_datatype ` 
  t = E_record of (label#t) list  `;
</PRE><P>For Coq we provide two alternatives: one can either use
native lists, or lists can be translated away, depending on taste.
The choice is determined by the <CODE>-coq_expand_list_types</CODE>
command-line option.
In the former case we generate an appropriate induction principle
using nested fixpoints, as
the default principle produced by Coq is too weak to be useful.
In the latter case we
synthesise an additional type for each type of lists-of-tuples that
arises in the grammar. 
In the example, we need a type of lists of
pairs of a <TT>label</TT> and a <TT>t</TT>:
</P><PRE CLASS="verbatim">Inductive 
list_label_t : Set := 
   Nil_list_label_t : list_label_t
 | Cons_list_label_t : label -&gt; t -&gt; list_label_t 
     -&gt; list_label_t

with t : Set := 
   E_record : list_label_t -&gt; t .
</PRE><P>These are included in the grammar topological sort, and utility functions, e.g.&#XA0;to 
make and unmake lists, are synthesised. 
</P><!--TOC subsubsection Terms (in inductive definition rules)-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc40">12.3.2</A>&#XA0;&#XA0;Terms (in inductive definition rules)</H4><!--SEC END --><P>
Supporting list forms in the rules of an inductive definition requires some additional analysis. For example,
consider the record typing rule below.</P><P><IMG SRC="top2034.gif"></P><P>We analyse the symbolic terms in the premises and conclusion to
identify lists of nonterminals and metavariables with the same bounds &#X2014; here <I>t</I><SUB>0</SUB> .. <I>t</I><SUB><I>n</I>&#X2212;1</SUB>, <I>T</I><SUB>0</SUB> .. <I>T</I><SUB><I>n</I>&#X2212;1</SUB>, and <I>l</I><SUB>0</SUB> .. <I>l</I><SUB><I>n</I>&#X2212;1</SUB>
all have bounds 0..<I>n</I>&#X2212;1.
To make the fact that they have the same length immediate in the
generated code, we introduce a single proof assistant
variable for each such collection, with appropriate projections and
list maps/foralls at the usage points.
For example, the HOL for the above is essentially as follows, with
an <CODE>l_t_Typ_list : (label#t#Typ) list</CODE>.
</P><PRE CLASS="verbatim">(* Ty_Rcd *)  !(l_t_Typ_list:(label#t#Typ) list) (G:G) . 
(EVERY (\b.b) 
  (MAP (\(l_,t_,Typ_). (Ty G t_ Typ_)) l_t_Typ_list))
 ==&gt; 
(Ty 
  G 
  (E_record (MAP (\(l_,t_,Typ_). (l_,t_)) l_t_Typ_list))
  (T_Rec    (MAP (\(l_,t_,Typ_). (l_,Typ_)) l_t_Typ_list)))
</PRE><P>This seems to be a better idiom for later proof development than the
alternative of three different list variables coupled with assertions
that they have the same length. </P><P>With direct support for lists, we need also direct support for 
symbolic terms involving list projection and concatenation.
For example, the rule
</P><P><IMG SRC="top2035.gif"></P><P>gives rise to HOL code as below &#X2014; note the list-lifted usage of the
<CODE>is_v_of_t</CODE> predicate, and the list appends (<TT>++</TT>) in the conclusion.
</P><PRE CLASS="verbatim">(* reduce_Rec *)  !(l'_t'_list:(label#t) list) 
       (l_v_list:(label#t) list) (l:label) (t:t) (t':t) . 
((EVERY (\(l_,v_). is_v_of_t v_) l_v_list) /\
(( reduce t t' )))
 ==&gt; 
(( reduce (t_Rec (l_v_list ++ [(l,t)] ++ l'_t'_list)) 
          (t_Rec (l_v_list ++ [(l,t')] ++ l'_t'_list))))
</PRE><P>For the <TT>Proj</TT> typing rule </P><P><IMG SRC="top2036.gif"></P><P>we need a specific projection (the
HOL <CODE>EL</CODE>) to
pick out the <I>j</I>&#X2019;th element:
</P><PRE CLASS="verbatim">(* Ty_Proj *)  !(l_Typ_list:(label#Typ) list) 
       (j:index) (G:G) (t:t) . 
((( Ty G t (T_Rec (l_Typ_list)) )))
 ==&gt; 
(( Ty 
     G 
     (t_Proj t  ((\ (l_,Typ_) . l_) (EL j l_Typ_list)))  
     ((\ (l_,Typ_) . Typ_) (EL  j l_Typ_list))))
</PRE><P>For Coq, when translating away lists, we have to introduce 
yet more list types for 
these proof assistant variables, in addition to the obvious
translation of symbolic terms, and, more substantially, to introduce additional inductive relation
definitions to induct over them.</P><P>For similar examples in Isabelle, the generated Isabelle for the first
three rules of &#XA7;<A HREF="#a66">12.1</A> is
shown below (lightly hand-edited for format). The first involves an
Isabelle variable <CODE>l_t_T_list</CODE>, and list maps and projections
thereof.
</P><PRE CLASS="verbatim">Ty_RcdI: "
  [|(formula_formuladots ((List.map (%(l_,t_,T_).( ( G , t_ , T_ ) : Ty)) l_t_T_list)))|] 
  ==&gt; 
  ( G , 
    (t_Rec ((List.map (%(l_,t_,T_).(l_,t_)) l_t_T_list))) , 
    (T_Rec ((List.map (%(l_,t_,T_).(l_,T_)) l_t_T_list))) 
  ) : Ty"

Ty_ProjI: "
  [| ( G , t , (T_Rec (l_T_list)) ) : Ty|] ==&gt; 
  ( G , 
    (t_Proj t (%(l_,T_).l_) (List.nth l_T_list (j - 1))) , 
    (%(l_,T_).T_) (List.nth l_T_list (j - 1)) 
  ) : Ty"

E_Ctx_recordI: "
[| List.list_all (%(l_,v_).is_v v_) l_v_list ;
   ( t , t' ) : E|] 
==&gt; 
 ( (t_Rec (l_v_list @ [(l,t)] @ l_'t_'list)) , 
   (t_Rec (l_v_list @ [(l,t')] @ l_'t_'list)) 
 ) : E"
</PRE><P>
The generated code for substitutions and free variables takes account of such list structure.</P><P>Note that at present the generated Isabelle code for these functions
does not always build without change, in particular if tuples of size
3 or more are required in patterns.</P><!--TOC subsubsection List forms in homomorphisms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc41">12.3.3</A>&#XA0;&#XA0;List forms in homomorphisms</H4><!--SEC END --><P>Proof assistant homomorphisms in productions can refer to dot-form
metavariables and nonterminals. For example, the second production
below (taken from <CODE>test17.9</CODE>) mentions <TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>x1 t1 </TT><TT><FONT COLOR="#007FFF">...</FONT></TT><TT> xn tn</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT> in the <FONT COLOR="#A51815"><TT>isa</TT></FONT>
homomorphism. This must exactly match the dot form in the production
except that all terminals must be omitted &#X2014; the metavariables and
nonterminals must occur in the same order as in the production, and
the bounds must be the same. </P><PRE>
    E <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;E_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> ( ident * t ) list  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
      <FONT COLOR="#007FFF"><TT>|</TT></FONT> &lt; x1 : t1 , <FONT COLOR="#007FFF"><TT>..</TT></FONT> , xn : tn &gt; <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> 2  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT>  List.rev <FONT COLOR="#007FFF"><TT>[[</TT></FONT>x1 t1 <FONT COLOR="#007FFF"><TT>..</TT></FONT> xn tn<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
    <FONT COLOR="#A51815"><TT>formula</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> formula_ <FONT COLOR="#007FFF"><TT>::=</TT></FONT>          
      <FONT COLOR="#007FFF"><TT>|</TT></FONT> judgement              <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> judgement
      <FONT COLOR="#007FFF"><TT>|</TT></FONT> formula1 <FONT COLOR="#007FFF"><TT>..</TT></FONT> formulan   <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> dots
</PRE><P>
The generated Isabelle code for symbolic
terms mentioning this production will involve a list of pairs. For
example, the rules
</P><PRE>
<FONT COLOR="#A51815"><TT>defn</TT></FONT>
|- E  <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Eok <FONT COLOR="#007FFF"><TT>::</TT></FONT> Eok_ <FONT COLOR="#A51815"><TT>by</TT></FONT>

<FONT COLOR="#007FFF"><TT>----------------------------</TT></FONT> :: 2
|- &lt;x1:t1,..,xn:tn&gt; 

|- t1:K1  .. |- tn:Kn
<FONT COLOR="#007FFF"><TT>----------------------------</TT></FONT> :: 3
|- &lt;x1:t1,..,xn:tn&gt; 
</PRE><P>
generate
</P><PRE CLASS="verbatim">consts
  Eok :: "E set"
inductive Eok tK
intros

(* defn Eok *)

Eok_2I: " ( List.rev  (x_t_list) ) : Eok"

Eok_3I: "[|
(List.list_all (\&lt;lambda&gt; b . b) (  ((List.map (%(x_,t_,K_). ( t_ , K_ ) : tK) x_t_K_list))  ) )|]
 ==&gt; 
 ( List.rev  ((List.map (%(x_,t_,K_).(x_,t_)) x_t_K_list)) ) : Eok"
 </PRE><P>
Note that in the second the list of pairs is projected out from the
<CODE>x_t_K_list</CODE> list of triples that is quantified over in the rule.</P><!--TOC section Subrules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc42">13</A>&#XA0;&#XA0;Subrules</H2><!--SEC END --><P><A NAME="a14"></A>Subrule declarations have the form
</P><PRE>
  <FONT COLOR="#A51815"><TT>subrules</TT></FONT>
    nt1 <FONT COLOR="#007FFF"><TT>&lt;::</TT></FONT> nt2
</PRE><P>
where <TT>nt1</TT> and <TT>nt2</TT> are nonterminal roots. </P><P>Subrules can be chained, i.e.&#XA0;there can be a pair of
subrule declarations <TT>nt1 </TT><TT><FONT COLOR="#007FFF">&lt;::</FONT></TT><TT> nt2</TT> and <TT>nt2 </TT><TT><FONT COLOR="#007FFF">&lt;::</FONT></TT><TT> nt3</TT>,
and they can form a directed acyclic graph, e.g.&#XA0;with 
<TT>nt0 </TT><TT><FONT COLOR="#007FFF">&lt;::</FONT></TT><TT> nt1</TT>, <TT>nt0 </TT><TT><FONT COLOR="#007FFF">&lt;::</FONT></TT><TT> nt2</TT>,
<TT>nt1 </TT><TT><FONT COLOR="#007FFF">&lt;::</FONT></TT><TT> nt3</TT>, and <TT>nt2 </TT><TT><FONT COLOR="#007FFF">&lt;::</FONT></TT><TT> nt3</TT>. However, there cannot be
cycles, or nonterminal roots for which there are multiple upper bounds. 
Subrule declarations should not involve nonterminal roots for which
proof-assistant type homs are specified. </P><P>We support the case in which the upper rule is also
non-free, i.e.&#XA0;it contains productions that mention nonterminals that
occur on the left of a subrule declaration. In the example below
(<TT>test11.ott</TT>) the
<TT>t</TT> rule contains a production <TT>Foo v</TT>.
</P><PRE>
  <FONT COLOR="#A51815"><TT>metavar</TT></FONT> termvar <FONT COLOR="#007FFF"><TT>,</TT></FONT> x <FONT COLOR="#007FFF"><TT>::=</TT></FONT>
    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> string <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq</TT></FONT> nat <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>coq-equality</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>hol</TT></FONT> string <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>ocaml</TT></FONT> int <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>

  <FONT COLOR="#A51815"><TT>grammar</TT></FONT>
    t <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;t_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>                                         
      <FONT COLOR="#007FFF"><TT>|</TT></FONT> x                   <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> Var                   
      <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT> x . t             <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam  <FONT COLOR="#007FFF"><TT>(+</TT></FONT> <FONT COLOR="#A51815"><TT>bind</TT></FONT> x <FONT COLOR="#A51815"><TT>in</TT></FONT> t <FONT COLOR="#007FFF"><TT>+)</TT></FONT>
      <FONT COLOR="#007FFF"><TT>|</TT></FONT> t t&#X2019;                <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> App                   
      <FONT COLOR="#007FFF"><TT>|</TT></FONT> Foo v               <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> Foo

    v <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;v_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>                        
      <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT> x . t             <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam   

  <FONT COLOR="#A51815"><TT>subrules</TT></FONT>
    v <FONT COLOR="#007FFF"><TT>&lt;::</TT></FONT> t

  <FONT COLOR="#A51815"><TT>defns</TT></FONT>
    Jb <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X201D; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>

      <FONT COLOR="#A51815"><TT>defn</TT></FONT>
      Baz t , v <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Baz <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X201D;       <FONT COLOR="#A51815"><TT>by</TT></FONT> 

      
<FONT COLOR="#007FFF"><TT>      ---------</TT></FONT> :: ax
      Baz t , v
</PRE><P>

In this case generated Isabelle/Coq/HOL/OCaml will define a single type and both <TT>is_v</TT>
and <TT>is_t</TT> predicates, and the generated inductive definition
clause for <TT>ax</TT> uses both predicates. The Isabelle clause is below.
</P><PRE CLASS="verbatim">  axI: "[|is_t t ; is_v v|] ==&gt;  ( t , v ) : Baz"
</PRE><!--TOC section Context rules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc43">14</A>&#XA0;&#XA0;Context rules</H2><!--SEC END --><P><A NAME="a69"></A>The system supports the definition of single-hole contexts, e.g.&#XA0;for
evaluation contexts. For example, suppose one has a term grammar as below:
</P><PRE>
t <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;t_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>                               <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> term    <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> x                  <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Var                   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> variable<FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT> x . t            <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam <FONT COLOR="#007FFF"><TT>(+</TT></FONT> <FONT COLOR="#A51815"><TT>bind</TT></FONT> x <FONT COLOR="#A51815"><TT>in</TT></FONT> t <FONT COLOR="#007FFF"><TT>+)</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> lambda  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> t t&#X2019;               <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> App                   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> app     <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> ( t1 , <FONT COLOR="#007FFF"><TT>....</TT></FONT> , tn ) <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Tuple                 <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> tuple <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> ( t )              <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>S</TT></FONT><FONT COLOR="#007FFF"><TT>::</TT></FONT> Paren                 <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>icho</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT>  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>{</TT> t / x <TT>}</TT> t&#X2019;       <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT><FONT COLOR="#007FFF"><TT>::</TT></FONT> Tsub  
                        <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>icho</TT></FONT> (tsubst_t <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>x<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT>)<FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>

  <FONT COLOR="#007FFF"><TT>|</TT></FONT> E . t              <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT><FONT COLOR="#007FFF"><TT>::</TT></FONT> Ctx  
                        <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>icho</TT></FONT> (appctx_E_t <FONT COLOR="#007FFF"><TT>[[</TT></FONT>E<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT>)<FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
                        <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>E<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <TT>\</TT>cdot <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
A context grammar is declared as a normal grammar but with a single
occurrence of the terminal <CODE>__</CODE> in each production, e.g. as in
the grammar for <TT>E</TT> below (a rather strange evaluation
strategy, admittedly).
</P><PRE>
E <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;E_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>                               <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> evaluation context <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> __ t         <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> AppL                   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> app L    <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> v __         <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> AppR                   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> app R    <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT> x . __     <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam                    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> reduce under lambda <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> ( t1 ( __  t2 ) ) <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Nested              <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> hole nested <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> ( v1 , <FONT COLOR="#007FFF"><TT>..</TT></FONT> , vm , __ , t1 , <FONT COLOR="#007FFF"><TT>..</TT></FONT> , tn ) <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Tuple <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> tuple <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
A <FONT COLOR="#A51815"><TT>contextrules</TT></FONT> declaration:
</P><PRE>
<FONT COLOR="#A51815"><TT>contextrules</TT></FONT>
  E <FONT COLOR="#007FFF"><TT>_::</TT></FONT> t <FONT COLOR="#007FFF"><TT>::</TT></FONT> t
</PRE><P>
causes Ott to (a) check that each production of the <TT>E</TT> grammar
is indeed a context for the <TT>t</TT> grammar, and (b) generates
proof assistant functions, e.g.&#XA0;<CODE>appctx_E_t</CODE>, to apply a context
to a term:
</P><PRE CLASS="verbatim">(** context application *)
Definition appctx_E_t (E5:E) (t_6:t) : t :=
  match E5 with
  | (E_AppL t5) =&gt; (t_App t_6 t5)
  | (E_AppR v5) =&gt; (t_App v5 t_6)
  | (E_Lam x) =&gt; (t_Lam x t_6)
  | (E_Nested t1 t2) =&gt;  (t_App t1  (t_App t_6 t2) )
  | (E_Tuple v_list t_list) =&gt; (t_Tuple ((app_list_t v_list
     (app_list_t (Cons_list_t t_6 Nil_list_t) (app_list_t t_list Nil_list_t)))))
</PRE><P>As the <TT>Nested</TT> production shows, context productions can
involve nested term structure.</P><P>Note also that here the <TT>E</TT> grammar is not free (it mentions the
subrule nonterminal <TT>v</TT>) so an isvalue predicate
<CODE>is_E_of_E</CODE> is also generated.</P><P>In general, context rule declarations have the form
</P><PRE>
  <FONT COLOR="#A51815"><TT>contextrules</TT></FONT>
    ntE <FONT COLOR="#007FFF"><TT>_::</TT></FONT> nt1 <FONT COLOR="#007FFF"><TT>::</TT></FONT> nt2
</PRE><P>
where <TT>ntE</TT>, <TT>nt1</TT>, and <TT>nt2</TT> are nonterminal
roots. This declares contexts <TT>ntE</TT> for the <TT>nt1</TT>
grammar, with holes in <TT>nt2</TT> positions.</P><P>Just as for substitutions, the context application function is
typically used by adding a metaproduction to the term grammar. 
Here we add a production <TT>E.t</TT> to the <TT>t</TT> grammar with
an <TT>icho</TT> hom that uses <CODE>appctx_E_t</CODE>.
</P><PRE>
t <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;t_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>                               <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> term    <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
  ...
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> E . t              <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT><FONT COLOR="#007FFF"><TT>::</TT></FONT> Ctx  
                        <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>icho</TT></FONT> (appctx_E_t <FONT COLOR="#007FFF"><TT>[[</TT></FONT>E<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT>)<FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
                        <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>E<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <TT>\</TT>cdot <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
That can then be used in relations:
</P><PRE>
    t &#X2013;&gt; t&#X2019;
<FONT COLOR="#007FFF"><TT>    --------------</TT></FONT> :: ctx
    E.t &#X2013;&gt; E.t&#X2019;
</PRE><P>One would typically also define a <TT>terminals</TT> production for
the hole terminal <CODE>__</CODE>, e.g.&#XA0;here we typeset the hole as [&#XB7;].
</P><PRE>
<FONT COLOR="#A51815"><TT>terminals</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;terminals_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> __           <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> hole    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> [<TT>\</TT>cdot] <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><!--TOC section Auxiliary Rules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc44">15</A>&#XA0;&#XA0;Auxiliary Rules</H2><!--SEC END --><P>
We permit an <TT>aux</TT> hom on grammar rules. For any rule with such a hom,
we transform that rule by appending an <TT>_aux</TT> to its primary nonterminal
root name. We then add a synthesised rule with the original nonterminal
root name and a single production, with a shape described by the body of 
the aux hom, which must be of the form 
</P><PRE CLASS="verbatim">  {{ aux  foo1 foo2 _ bar1 bar2 bar3 }}
</PRE><P>with a single <TT>_</TT> and any number of strings <TT>fooi</TT> and <TT>barj</TT> before and
after. The <TT>_</TT> is replaced by the original
nonterminal root name. </P><P>For example, given a grammar or metavariable <TT>l</TT> of source locations, one
might say 
</P><PRE CLASS="verbatim">ntr :: 'NTR_'  ::=  {{ aux _ l }}
 | ...
</PRE><P>to synthesise grammars <TT>ntr_aux</TT> and <TT>ntr</TT> of unannotated and location-annotated 
terms, the first with all the original productions and the second with a 
single production 
</P><PRE CLASS="verbatim"> | ntr l :: :: NTR_aux. 
</PRE><P>If the rule has an empty production name wrapper (eg with <TT>&#X2019;&#X2019;</TT> in place
of <TT>&#X2019;NTR_&#X2019;</TT>) then the production name is based on the original
nonterminal root, capitalised and with <TT>_aux</TT> appended (eg <TT>Ntr_aux</TT>), to
avoid spurious conflicts.</P><P>An additional <TT>auxparams</TT> hom on rules lets the user add type
parameters to the generated OCaml output. </P><P>Generation of aux rules is controlled by a command-line option
<TT>-generate_aux_rules</TT>, which one might (eg) set to false
for latex output and true for OCaml output.</P><!--TOC section Functions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc45">16</A>&#XA0;&#XA0;Functions</H2><!--SEC END --><P>Ott includes experimental support for writing function definitions.
As a simple example, consider the Ott file below:</P><PRE>
    <FONT COLOR="#A51815"><TT>grammar</TT></FONT>
     n <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;n_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>
       | 0       <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Zero
       | S n     <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> Succ

    <FONT COLOR="#A51815"><TT>funs</TT></FONT>
      Add <FONT COLOR="#007FFF"><TT>::=</TT></FONT>   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> hol-proof ...  <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
    <FONT COLOR="#A51815"><TT>fun</TT></FONT>
      n1 + n2 <FONT COLOR="#007FFF"><TT>::</TT></FONT> n <FONT COLOR="#007FFF"><TT>::</TT></FONT> add    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> com a function of type num -&gt; num -&gt; num <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
    <FONT COLOR="#A51815"><TT>by</TT></FONT>
      0 + n2 <FONT COLOR="#007FFF"><TT>===</TT></FONT> n2
      S n1 + n2 <FONT COLOR="#007FFF"><TT>===</TT></FONT> n1 + S n2
</PRE><P>Here the <CODE>add</CODE> function is compiled into the following Coq code:</P><PRE>
    Fixpoint add (x1:num) (x2:num) : num:=
      match x1,x2 with
      | n_zero , n2 =&gt; n2
      | (n_succ n1) , n2 =&gt;  (add n1 (n_succ n2) ) 
    end.
</PRE><P>More in detail, the 
<FONT COLOR="#A51815"><TT>fun</TT></FONT>
n1 + n2 <FONT COLOR="#007FFF"><TT>::</TT></FONT> n <FONT COLOR="#007FFF"><TT>::</TT></FONT> add
<FONT COLOR="#A51815"><TT>by</TT></FONT>
declaration specifies:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the name of the function: <CODE>add</CODE>
</LI><LI CLASS="li-itemize">the symbolic term that defines the lhs: <CODE>n1 + n2</CODE>
</LI><LI CLASS="li-itemize">the non-terminal that defines the rhs: <CODE>n</CODE>
</LI></UL><P>The type of the arguments of the function is defined by the
non-terminals appearing in the lhs, the return type by the rhs
non-terminal (so <CODE>num</CODE> &#X2192; <CODE>num</CODE> &#X2192; <CODE>num</CODE> in the
above example). As side-effect, whenever a function of type
<CODE>symb_term</CODE> &#X2192; <CODE>nt</CODE> is defined, a production
<CODE>nt ::= symb_term</CODE> is added to the definition of the
non-terminal <CODE>nt</CODE> (in the above example, the production
<CODE>n1 + n2</CODE> is added to the grammar of <CODE>num</CODE>).</P><P>Functions are then defined by case analysis, where the lhs and the rhs
are separated by the reserved symbol <FONT COLOR="#007FFF"><TT>===</TT></FONT>.</P><P>The <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <CODE>hol-proof</CODE> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> hom
allows the specification of a termination proof, which is required by
Hol. Mutually recursive functions can be defined in the same
<FONT COLOR="#A51815"><TT>funs</TT></FONT> block, analogously to mutually recursive rule
definitions.</P><P><EM>Disclaimer:</EM> the different treatment of partial functions by the
different provers can result in a function definition being compiled
correctly to one prover but not to others.</P><!--TOC section Parsing Priorities-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc46">17</A>&#XA0;&#XA0;Parsing Priorities</H2><!--SEC END --><P>Symbolic terms that can have more than one parse tree are typically considered
erroneous; however, certain classes of parse trees are ignored in order to
support common idioms that are ambiguous. For example, the production 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X393;&#XA0;::=&#XA0;&#X393;<SUB>1</SUB>,&#XA0;..,&#XA0;&#X393;<SUB><I>n</I></SUB></TD></TR>
</TABLE><P>
might be used to allow a list of typing contexts to be appended together, but
it is highly ambiguous. The following restrictions forbid many unwanted parses
that could otherwise occur.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
All parses in which a nonterminal derives itself without consuming any input
are ignored. For example, in the production above, the list could otherwise be
of length one so that &#X393; directly derives &#X393; giving rise to a
vacuous cycle, and an infinite forest of parse trees. This restriction
ensures that only the tree without the vacuous cycle is considered.
</LI><LI CLASS="li-itemize">The parser for a list form ignores parses that unnecessarily break up the list
due to (direct or indirect) self reference. For example,
&#X393;<SUB>1</SUB>,&#X393;<SUB>2</SUB>,&#X393;<SUB>3</SUB>,&#X393;<SUB>4</SUB> will not parse as a two element sequence
of two element sequences (&#X393;<SUB>1</SUB>,&#X393;<SUB>2</SUB>),(&#X393;<SUB>3</SUB>,&#X393;<SUB>4</SUB>) given the
production above.
</LI><LI CLASS="li-itemize">User supplied priority annotations in a <FONT COLOR="#A51815"><TT>parsing</TT></FONT> section rule out certain
trees as follows:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<I><I>prodname</I></I><SUB>1</SUB> <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> <I><I>prodname</I></I><SUB>2</SUB>: Parse trees where a
<I><I>prodname</I></I><SUB>1</SUB> node is a child of a <I><I>prodname</I></I><SUB>2</SUB> node are
ignored.
</LI><LI CLASS="li-itemize"><I><I>prodname</I></I><SUB>1</SUB>&#XA0;<FONT COLOR="#A51815"><TT>right</TT></FONT>&#XA0;<I><I>prodname</I></I><SUB>2</SUB>: Parse trees where a
<I><I>prodname</I></I><SUB>1</SUB> node is the leftmost child of a <I><I>prodname</I></I><SUB>1</SUB>
node are ignored.
</LI><LI CLASS="li-itemize"><I><I>prodname</I></I><SUB>1</SUB>&#XA0;<FONT COLOR="#A51815"><TT>left</TT></FONT>&#XA0;<I><I>prodname</I></I><SUB>2</SUB>: Parse trees where a
<I><I>prodname</I></I><SUB>2</SUB> node is the rightmost child of a <I><I>prodname</I></I><SUB>1</SUB>
node are ignored.
</LI></UL>
In addition to immediate children, these priority annotations also prohibit
parse trees where the forbidden child node occurs underneath a chain of
derivations from the specified parent when the chain does not consume any
input.
Figure&#XA0;<A HREF="#parsing_figure">17</A> demonstrates a typical use of a <FONT COLOR="#A51815"><TT>parsing</TT></FONT>
section; the declarations have effect as follows:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Line #1: <CODE>n + n + n</CODE> parses as <CODE>(n + n) + n</CODE>, but not <CODE>n + (n + n)</CODE>;
</LI><LI CLASS="li-itemize">Line #3: <CODE>n + n - n</CODE> parses as <CODE>(n + n) - n</CODE>, but not <CODE>n + (n - n)</CODE>;
</LI><LI CLASS="li-itemize">Line #9: <CODE>-n + n</CODE> parses as <CODE>(-n) + n</CODE>, but not <CODE>-(n + n)</CODE>;
</LI><LI CLASS="li-itemize">Line #15: <CODE>n + n n</CODE> parses as <CODE>n + (n n)</CODE>, but not <CODE>(n + n) n</CODE>;
<CODE>n n + n</CODE> parses as <CODE>(n n) + n</CODE>, but not <CODE>n (n + n)</CODE>;
</LI><LI CLASS="li-itemize">Line #20: <CODE>n, n n, n</CODE> parses as <CODE>n, (n n), n</CODE>, but not <CODE>(n, n) (n, n)</CODE>.
</LI></UL>
Currently, the <FONT COLOR="#A51815"><TT>parsing</TT></FONT> section supports only these relatively low level
and verbose declarations.
</LI></UL><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><PRE>
<PRE>
<FONT COLOR="#A51815"><TT>metavar</TT></FONT> n <FONT COLOR="#007FFF"><TT>::=</TT></FONT>

<FONT COLOR="#A51815"><TT>grammar</TT></FONT>

e <FONT COLOR="#007FFF"><TT>::</TT></FONT> e_ <FONT COLOR="#007FFF"><TT>::=</TT></FONT> 
<FONT COLOR="#007FFF"><TT>|</TT></FONT> n             <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> num
<FONT COLOR="#007FFF"><TT>|</TT></FONT> - e           <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> neg
<FONT COLOR="#007FFF"><TT>|</TT></FONT> e1 + e2       <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> add
<FONT COLOR="#007FFF"><TT>|</TT></FONT> e1 - e2       <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> sub
<FONT COLOR="#007FFF"><TT>|</TT></FONT> e1 e2         <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> mul
<FONT COLOR="#007FFF"><TT>|</TT></FONT> e1 / e2       <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> div
<FONT COLOR="#007FFF"><TT>|</TT></FONT> e1 , <FONT COLOR="#007FFF"><TT>..</TT></FONT> , e2  <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> tup
<FONT COLOR="#007FFF"><TT>|</TT></FONT> ( e )         <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#A51815"><TT>M</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> par <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>icho</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>e<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>

<FONT COLOR="#A51815"><TT>parsing</TT></FONT>

e_add <FONT COLOR="#A51815"><TT>left</TT></FONT> e_add   % #1
e_sub <FONT COLOR="#A51815"><TT>left</TT></FONT> e_sub
e_add <FONT COLOR="#A51815"><TT>left</TT></FONT> e_sub   % #3
e_sub <FONT COLOR="#A51815"><TT>left</TT></FONT> e_add

e_mul <FONT COLOR="#A51815"><TT>left</TT></FONT> e_mul
e_div <FONT COLOR="#A51815"><TT>left</TT></FONT> e_div
e_mul <FONT COLOR="#A51815"><TT>left</TT></FONT> e_div
e_div <FONT COLOR="#A51815"><TT>left</TT></FONT> e_mul

e_neg <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_add     % #9
e_neg <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_sub
e_neg <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_mul
e_neg <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_div
e_neg <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_tup

e_add <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_div
e_add <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_mul     % #15
e_add <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_tup
e_sub <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_div
e_sub <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_mul
e_sub <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_tup

e_mul <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_tup     % #20
e_div <FONT COLOR="#007FFF"><TT>&lt;=</TT></FONT> e_tup

</PRE>

<A NAME="parsing_figure"></A>
</PRE><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 14: An Ott source file for basic arithmetic using the typical parsing priorities</TD></TR>
</TABLE></DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Combining multiple source files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc47">18</A>&#XA0;&#XA0;Combining multiple source files</H2><!--SEC END --><P>
Ott can be invoked with multiple source files.
Input filenames with extensions <TT>.tex</TT>, <TT>.v</TT>,
<TT>.thy</TT>, <TT>.sml</TT>, or <TT>ml</TT> are simply copied into
the relevant output (L<sup>A</sup>T<sub>E</sub>X, Coq, Isabelle, HOL, or OCaml). 
By default the source-file and command-line order of blocks is preserved, for grammar,
embeds, and inductive definitions.</P><P>The prover output can be split into multiple output files: each prover
output file specified with <TT>-o &lt;filename&gt;</TT> will contain the material
from the previous input files specified with <TT>-i</TT> (since the last <TT>-o</TT>
for the same prover).</P><P>Alternatively, one can add a <TT>-merge true</TT> command-line option,
in which case
the productions of multiple grammars that share the same header
are merged into a single grammar, and the rules of multiple
inductive definitions that share the same header are merged into a
single inductive definition. 
This rudimentary form of modularity can be very useful, either to
split a language definition into separate features, or to define
reusable Ott components to define standard formulae, LaTeX pretty
printing of terminals, or LaTeX styles. 
For example, Figure&#XA0;<A HREF="#a12">15</A> shows the Ott source file for a
<TT>let</TT> feature in isolation, taken from our Ott development of
some languages from Pierce&#X2019;s TAPL&#XA0;[<A HREF="#Pierce:TypeSystems">Pie02</A>].
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="minipage"><SPAN CLASS="textboxed">
</SPAN><PRE><SPAN CLASS="textboxed">
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>grammar</TT></FONT></SPAN><SPAN CLASS="textboxed">
t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Tm </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">                                        </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> terms: </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> let x = t in t&#X2019;                   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Let </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>(+</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>bind</TT></FONT></SPAN><SPAN CLASS="textboxed"> x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>in</TT></FONT></SPAN><SPAN CLASS="textboxed"> t&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>+)</TT></FONT></SPAN><SPAN CLASS="textboxed">     </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> let binding </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">


</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defns</TT></FONT></SPAN><SPAN CLASS="textboxed"> 
Jop </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X201D; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed"> 

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defn</TT></FONT></SPAN><SPAN CLASS="textboxed"> 
t &#X2013;&gt; t&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> red </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> E_ </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> Evaluation </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>by</TT></FONT></SPAN><SPAN CLASS="textboxed">

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>-----------------------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: LetV
let x=v1 in t2 &#X2013;&gt; [x|-&gt;v1]t2 

t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>----------------------------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: Let
let x=t1 in t2 &#X2013;&gt; let x=t1&#X2019; in t2


</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defns</TT></FONT></SPAN><SPAN CLASS="textboxed">
Jtype </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X201D; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed"> 

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defn</TT></FONT></SPAN><SPAN CLASS="textboxed">
G |- t : T </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> typing </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> T_ </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> Typing </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>by</TT></FONT></SPAN><SPAN CLASS="textboxed">

G |- t1:T1
G,x:T1 |- t2:T2
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>------------------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: Let
G |- let x=t1 in t2 : T2
</SPAN></PRE><SPAN CLASS="textboxed">
</SPAN></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 15: An <TT>ott</TT> source file for the <TT>let</TT> fragment of TAPL<A NAME="a12"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>
The original TAPL languages were produced using
TinkerType&#XA0;[<A HREF="#LevinPierce99">LP03</A>] to compose features and check for
conflicts. 
In <TT>examples/tapl</TT> we build a system, similar to the TinkerType
<TT>sys-fullsimple</TT>, from <TT>ott</TT> source files that
correspond roughly to the various TinkerType components, each with
syntax and semantic rules for a single feature. </P><!--TOC section Hom blocks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc48">19</A>&#XA0;&#XA0;Hom blocks</H2><!--SEC END --><P>
Bindspecs and homomorphisms for productions, and any homomorphisms
for definitions, can appear in an Ott source file either 
attached to the production or definition, as we have shown earlier, or
in separate hom blocks.
For example, one can write
</P><PRE>
<FONT COLOR="#A51815"><TT>homs</TT></FONT> &#X2019;t_&#X2019;
  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam  <FONT COLOR="#007FFF"><TT>(+</TT></FONT> <FONT COLOR="#A51815"><TT>bind</TT></FONT> x <FONT COLOR="#A51815"><TT>in</TT></FONT> t <FONT COLOR="#007FFF"><TT>+)</TT></FONT>  

<FONT COLOR="#A51815"><TT>homs</TT></FONT> &#X2019;t_&#X2019;
  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Var     <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> variable <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>         
  <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam     <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> abstraction <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>      
  <FONT COLOR="#007FFF"><TT>::</TT></FONT> App     <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> application <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>      
  <FONT COLOR="#007FFF"><TT>::</TT></FONT> paren   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>ich</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
  <FONT COLOR="#007FFF"><TT>::</TT></FONT> tsub    <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>ich</TT></FONT> ( tsubst_t <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>x<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT> ) <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>

<FONT COLOR="#A51815"><TT>homs</TT></FONT> &#X201D;
  <FONT COLOR="#007FFF"><TT>::</TT></FONT> reduce  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>com</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t1<FONT COLOR="#007FFF"><TT>]]</TT></FONT> reduces to <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t2<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> 
</PRE><P>
Each of these begins with a prefix and then has a sequence of
production name or definition name kernels, each followed by a
sequence of bindspecs and then a sequence of homomorphisms.</P><P>The <CODE>test10_homs.ott</CODE> example, in Fig.&#XA0;<A HREF="#a38">16</A>, shows this. It
is semantically equivalent to the <CODE>test10.ott</CODE> example of
Fig.&#XA0;<A HREF="#a68">8</A>, but the homs have been moved into <TT>hom</TT>
blocks.
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="minipage"><SPAN CLASS="textboxed">
</SPAN><PRE><SPAN CLASS="textboxed">
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>metavar</TT></FONT></SPAN><SPAN CLASS="textboxed"> termvar </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>,</TT></FONT></SPAN><SPAN CLASS="textboxed"> x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed"> 
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>isa</TT></FONT></SPAN><SPAN CLASS="textboxed"> string </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>coq</TT></FONT></SPAN><SPAN CLASS="textboxed"> nat </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>coq-equality</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>hol</TT></FONT></SPAN><SPAN CLASS="textboxed"> string </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>lex</TT></FONT></SPAN><SPAN CLASS="textboxed"> alphanum </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>tex</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">mathit</SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">termvar</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed">  term variable  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> 

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>grammar</TT></FONT></SPAN><SPAN CLASS="textboxed">
  t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;t_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> term </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> x                   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Var   
    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed"> x . t             </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam  
    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> t t&#X2019;                </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> App  
    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> ( t )               </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>S</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> paren 
    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed"> t / x </SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed"> t&#X2019;        </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>M</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> tsub  

  v </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;v_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed">  value </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed"> x . t             </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam   

  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>terminals</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;terminals_&#X2019; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">
    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">                   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> lambda  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>tex</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">lambda </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">
    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>|</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2013;&gt;                 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> red     </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>tex</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">longrightarrow </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">


</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>homs</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;t_&#X2019;
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>(+</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>bind</TT></FONT></SPAN><SPAN CLASS="textboxed"> x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>in</TT></FONT></SPAN><SPAN CLASS="textboxed"> t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>+)</TT></FONT></SPAN><SPAN CLASS="textboxed">  

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>homs</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X2019;t_&#X2019;
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Var     </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> variable </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">         
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> Lam     </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> abstraction </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">      
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> App     </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> application </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">      
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> paren   </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>ich</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> 
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> tsub    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>ich</TT></FONT></SPAN><SPAN CLASS="textboxed"> ( tsubst_t </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">x</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t&#X2019;</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> ) </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed">

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>homs</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X201D;
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> reduce  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>{</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>com</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t1</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> reduces to </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>[[</TT></FONT></SPAN><SPAN CLASS="textboxed">t2</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>]]</TT></FONT></SPAN><SPAN CLASS="textboxed"> </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>}</TT></FONT></SPAN><SPAN CLASS="textboxed"> 


</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>subrules</TT></FONT></SPAN><SPAN CLASS="textboxed">
  v </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>&lt;::</TT></FONT></SPAN><SPAN CLASS="textboxed"> t

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>substitutions</TT></FONT></SPAN><SPAN CLASS="textboxed">
  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>single</TT></FONT></SPAN><SPAN CLASS="textboxed"> t x </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> tsubst 

</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defns</TT></FONT></SPAN><SPAN CLASS="textboxed">
  Jop </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X201D; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::=</TT></FONT></SPAN><SPAN CLASS="textboxed">

    </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>defn</TT></FONT></SPAN><SPAN CLASS="textboxed">
    t1 &#X2013;&gt; t2 </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed">  </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> reduce </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>::</TT></FONT></SPAN><SPAN CLASS="textboxed"> &#X201D; </SPAN><SPAN CLASS="textboxed"><FONT COLOR="#A51815"><TT>by</TT></FONT></SPAN><SPAN CLASS="textboxed"> 


</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------------------</TT></FONT></SPAN><SPAN CLASS="textboxed">  :: ax_app
    (</SPAN><SPAN CLASS="textboxed"><TT>\</TT></SPAN><SPAN CLASS="textboxed">x.t12) v2 &#X2013;&gt;  </SPAN><SPAN CLASS="textboxed"><TT>{</TT></SPAN><SPAN CLASS="textboxed">v2/x</SPAN><SPAN CLASS="textboxed"><TT>}</TT></SPAN><SPAN CLASS="textboxed">t12

    t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: ctx_app_fun
    t1 t &#X2013;&gt; t1&#X2019; t

    t1 &#X2013;&gt; t1&#X2019;
</SPAN><SPAN CLASS="textboxed"><FONT COLOR="#007FFF"><TT>    --------------</TT></FONT></SPAN><SPAN CLASS="textboxed"> :: ctx_app_arg
    v t1 &#X2013;&gt; v t1&#X2019;

</SPAN></PRE><SPAN CLASS="textboxed">

</SPAN></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 16: Hom Sections: <TT>test10_homs.ott</TT><A NAME="a38"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Isabelle syntax support-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc49">20</A>&#XA0;&#XA0;Isabelle syntax support</H2><!--SEC END --><P><A NAME="a39"></A>Ott has limited facilities to allow the Isabelle mixfix syntax support
and xsymbol to be used. The example <CODE>test10_isasyn.ott</CODE> shows
this in use. 
</P><P>Non-meta productions can be annotated with
<FONT COLOR="#A51815"><TT>isasyn</TT></FONT> and/or <FONT COLOR="#A51815"><TT>isaprec</TT></FONT> homomorphisms. 
For example, <CODE>test10_isasyn.ott</CODE> contains the production
</P><PRE>
  <FONT COLOR="#007FFF"><TT>|</TT></FONT> t t&#X2019;      <FONT COLOR="#007FFF"><TT>::</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> App   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isasyn</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t<FONT COLOR="#007FFF"><TT>]]</TT></FONT><TT>\</TT>&lt;bullet&gt;<FONT COLOR="#007FFF"><TT>[[</TT></FONT>t&#X2019;<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isaprec</TT></FONT> 50 <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
The two homs are used to output the Isabelle syntax annotation in the
<CODE>t_App</CODE> clause of the datatype definition below.
</P><PRE CLASS="verbatim">t = 
   t_Var "termvar"  
 | t_Lam "termvar" "t"  ("\&lt;lambda&gt; _ . _" 60)
 | t_App "t" "t"  ("_\&lt;bullet&gt;_" 50)
</PRE><P>
Definitions can be annotated with
<FONT COLOR="#A51815"><TT>isasyn</TT></FONT> and/or <FONT COLOR="#A51815"><TT>isaprec</TT></FONT> homomorphisms similarly, e.g.&#XA0;as below.
</P><PRE>
    <FONT COLOR="#A51815"><TT>defn</TT></FONT>
    t1 &#X2013;&gt; t2 <FONT COLOR="#007FFF"><TT>::</TT></FONT>  <FONT COLOR="#007FFF"><TT>::</TT></FONT> reduce <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X201D; <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isasyn</TT></FONT> <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t1<FONT COLOR="#007FFF"><TT>]]</TT></FONT> &#X2014;&gt; <FONT COLOR="#007FFF"><TT>[[</TT></FONT>t2<FONT COLOR="#007FFF"><TT>]]</TT></FONT> <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>  <FONT COLOR="#A51815"><TT>by</TT></FONT> 
</PRE><P>
This generates <CODE>syntax</CODE> and <CODE>translations</CODE> blocks as below.
</P><PRE CLASS="verbatim">inductive_set reduce :: "(t*t) set"
and  "reduce'" :: "t =&gt; t =&gt;  bool" ("_ ---&gt; _" 50)
where "(t1 ---&gt; t2) ==  ( t1 , t2 ) : reduce"
</PRE><P>
Symbolic terms in definitions are printed using any production or
definition syntax. This (especially with xsymbol turned on) makes the
current goal state during Isabelle proof development much more
readable. </P><P>Further, there is a command line option <CODE>-isa_syntax true</CODE>. If
this is set then the tool generates Isabelle syntax annotations from
the source syntax. For example, the source file production for the
<CODE>t_Lam</CODE> clause is
</P><PRE>
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT> x . t             <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> Lam   <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isaprec</TT></FONT> 60 <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
and the <CODE>terminals</CODE> grammar contains a mapping from <CODE>\</CODE> to <CODE>\&lt;lambda&gt;</CODE>:
</P><PRE>
  <FONT COLOR="#A51815"><TT>terminals</TT></FONT> <FONT COLOR="#007FFF"><TT>::</TT></FONT> &#X2019;terminals_&#X2019; <FONT COLOR="#007FFF"><TT>::=</TT></FONT>
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> <TT>\</TT>                   <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> lambda  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>lambda <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>  <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> <TT>\</TT>&lt;lambda&gt; <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
    <FONT COLOR="#007FFF"><TT>|</TT></FONT> &#X2013;&gt;                 <FONT COLOR="#007FFF"><TT>::</TT></FONT>   <FONT COLOR="#007FFF"><TT>::</TT></FONT> red     <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>tex</TT></FONT> <TT>\</TT>longrightarrow <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT> <FONT COLOR="#007FFF"><TT>{</TT></FONT><FONT COLOR="#007FFF"><TT>{</TT></FONT> <FONT COLOR="#A51815"><TT>isa</TT></FONT> &#X2014;&gt; <FONT COLOR="#007FFF"><TT>}</TT></FONT><FONT COLOR="#007FFF"><TT>}</TT></FONT>
</PRE><P>
This is used (just as for LaTeX homs) to generate the <CODE>("\&lt;lambda&gt; _ . _" 60)</CODE>
in the datatype definition above.</P><P>This functionality is limited in various ways:
(1) the full range of Isabelle precedence and associativity
specifications are not supported;
(2) the automatically generated syntax annotations are somewhat crude,
especially w.r.t.&#XA0;spacing and parenthesisation;
(3) syntax annotation on meta productions is not propertly supported;
and
(4) it would be desirable to have more fine-grain control of whether
to automatically generate annotations: per-production, per-rule, and
per-file.</P><!--TOC section Isabelle code generation example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc50">21</A>&#XA0;&#XA0;Isabelle code generation example</H2><!--SEC END --><P><A NAME="a22"></A>The Isabelle/Coq/HOL code generation facilities can be sometimes used to
generate (variously) OCaml and SML code from the Isabelle/Coq/HOL
definitions produced by Ott.</P><P>For example, the <CODE>test10st_codegen.thy</CODE> file uses Isabelle
code generation to produce SML code to calculate the possible
reductions of terms in the <CODE>test10st.ott</CODE> simply typed lambda
calculus.</P><PRE CLASS="verbatim">theory test10st_codegen 
imports test10st_snapshot_out Executable_Set
begin

ML "reset Codegen.quiet_mode"

(* Code generation for the test10st simply typed lambda calculus. *)

constdefs
 ta :: t
"ta == (t_App (t_Lam ''z'' (t_Var ''z''))) (t_Lam ''y'' (t_Var ''y''))"
;

code_module Test10st_codegen file "test10st_codegen.ml" contains 
(*is_v
tsubst_T
tsubst_t*)
reduce_ta  = "(ta,_):reduce"


(* ...to build and demo the resulting test10st_codegen.ml code...

Isabelle test10st_codegen.thy
...`use' that...

...in a shell...
isabelle
use "test10st_codegen.ml";
open Test10st_codegen;

...a test term...
ta;
val it = t_App (t_Lam (["z"], t_Var ["z"]), t_Lam (["y"], t_Var ["y"]))

...a sample reduction...
DSeq.hd(reducep__1 ta);
val it = t_Lam (["y"], t_Var ["y"]) : Test10st_codegen.t 

*)

end
</PRE><!--TOC section Reference: Command-line usage-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc51">22</A>&#XA0;&#XA0;Reference: Command-line usage</H2><!--SEC END --><P><A NAME="a32"></A>A good place to get started is one of the test
<TT>make</TT> targets in the <TT>ott</TT> directory, e.g.
</P><PRE CLASS="verbatim">test10: tests/test10.ott
           bin/ott                                                \
                  -i tests/test10.ott                             \ 
                  -o out.thy -o out.v -o outScript.sml            \
                  -o out.tex                                      \
                  -parse ":t:  (\z.z z) y"                        \                  
           &amp;&amp; ($(LATEX) out; $(DVIPS) out -o)
</PRE><P>When <CODE>make test10</CODE> is executed, <TT>ott</TT>:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
reads the source file <CODE>tests/test10.ott</CODE>
</LI><LI CLASS="li-itemize">(if one also specifies <TT>-show_post_sort true</TT> and <TT>-show_defns
true</TT>) prints on standard output various diagnostic information,
including ASCII versions of the grammar and
inductive definitions.
By default these are coloured (using
<CODE>vt220</CODE> control codes) with metavariables in red, nonterminals
in yellow, terminals in green, and object variables in white.
Scanning over this output quickly picks up some common errors.
</LI><LI CLASS="li-itemize">parses the symbolic term <CODE>(\z.z z) y</CODE> using the <CODE>t</CODE>
grammar and prints the result to standard output
</LI><LI CLASS="li-itemize">generates Isabelle definitions in the file <CODE>out.thy</CODE>
</LI><LI CLASS="li-itemize">generates Coq definitions in the file <CODE>out.v</CODE>
</LI><LI CLASS="li-itemize">generates HOL definitions in the file <CODE>outScript.sml</CODE>
</LI><LI CLASS="li-itemize">generates a LaTeX document in the file <CODE>out.tex</CODE>, with a
standard document preamble to make it self-contained.
</LI></UL><P>
That LaTeX document is then compiled and converted to postscript. </P><P>For convenience, input files can also be listed at the end of the command line:
</P><PRE CLASS="verbatim">  ott [options] &lt;file1&gt; ... &lt;filen&gt;
</PRE><P>is equivalent to
</P><PRE CLASS="verbatim">  ott -i &lt;file1&gt; ... -i &lt;filen&gt; [options]
</PRE><P>The&#XA0;<CODE>%.out</CODE> <CODE>Makefile</CODE> target runs <CODE>ott</CODE> with common
defaults on the file&#XA0;<CODE>%.ott</CODE>, so for example executing <CODE>make tests/test10.out</CODE>
runs <CODE>ott</CODE> on <CODE>tests/test10.ott</CODE>, generating all outputs. There are
also targets &#XA0;<CODE>%.coq.out</CODE>, &#XA0;<CODE>%.hol.out</CODE>, and
&#XA0;<CODE>%.isa.out</CODE>, to generate just LaTeX and the code for one proof
assistant, and &#XA0;<CODE>%.tex.out</CODE>, to generate just LaTeX.</P><P>The <TT>ott</TT> command-line options (with default values where applicable) are
shown below. 
</P><PRE CLASS="verbatim">Ott version 0.25   distribution of Thu Sep 4 18:04:34 BST 2014

usage: ott &lt;options&gt; &lt;filename1&gt; .. &lt;filenamen&gt; 
  (use "OCAMLRUNPARAM=p  ott ..." to show the ocamlyacc trace)
  (ott &lt;options&gt; &lt;filename1&gt; .. &lt;filenamen&gt;    is equivalent to
   ott -i &lt;filename1&gt; .. -i &lt;filenamen&gt; &lt;options&gt;)

  -i &lt;filename&gt;                      Input file (can be used multiple times)
  -o &lt;filename&gt;                      Output file (can be used multiple times)
  -writesys &lt;filename&gt;               Output system definition
  -readsys &lt;filename&gt;                Input system definition
  -tex_filter &lt;src&gt;&lt;dst&gt;             Files to TeX filter
  -coq_filter &lt;src&gt;&lt;dst&gt;             Files to Coq filter
  -hol_filter &lt;src&gt;&lt;dst&gt;             Files to HOL filter
  -lem_filter &lt;src&gt;&lt;dst&gt;             Files to HOL filter
  -isa_filter &lt;src&gt;&lt;dst&gt;             Files to Isabelle filter
  -ocaml_filter &lt;src&gt;&lt;dst&gt;           Files to OCaml filter
  -merge &lt;false&gt;                     merge grammar and definition rules
  -parse &lt;string&gt;                    Test parse symterm,eg ":nontermroot: term"
  -fast_parse &lt;false&gt;                do not parse :rulename: pseudoterminals
  -signal_parse_errors &lt;false&gt;       return &gt;0 if there are bad defns
  -picky_multiple_parses &lt;false&gt;     Picky about multiple parses
  -generate_aux_rules &lt;true&gt;         Generate auxiliary rules from {{ aux ... }} homs
  -output_source_locations &lt;0&gt;       Include source location info in output (0=none, 1=drules, 2=grammar+drules)
  -colour &lt;true&gt;                     Use (vt220) colour for ASCII pretty print
  -show_sort &lt;false&gt;                 Show ASCII pretty print of syntax
  -show_defns &lt;false&gt;                Show ASCII pretty print defns
  -tex_show_meta &lt;true&gt;              Include meta prods and rules in TeX output
  -tex_show_categories &lt;false&gt;       Signal production flags in TeX output
  -tex_colour &lt;true&gt;                 Colour parse errors in TeX output
  -tex_wrap &lt;true&gt;                   Wrap TeX output in document pre/postamble
  -tex_name_prefix &lt;string&gt;          Prefix for tex commands (default "ott")
  -isabelle_primrec &lt;true&gt;           Use "primrec" instead of "fun"
                                       for functions
  -isabelle_inductive &lt;true&gt;         Use "inductive" instead of "inductive_set"
                                       for relations
  -isa_syntax &lt;false&gt;                Use fancy syntax in Isabelle output
  -isa_generate_lemmas &lt;false&gt;       Lemmas for collapsed functions in Isabelle
  -coq_avoid &lt;1&gt;                     coq type-name avoidance
                                       (0=nothing, 1=avoid, 2=secondaryify)
  -coq_expand_list_types &lt;true&gt;      Expand list types in Coq output
  -coq_lngen &lt;false&gt;                 lngen compatibility
  -coq_names_in_rules &lt;true&gt;         Copy user names in rule definitions
  -coq_use_filter_fn &lt;false&gt;         Use list_filter instead of list_minus2 in substitutions
  -ocaml_include_terminals &lt;false&gt;   Include terminals in OCaml output (experimental!)
  -pp_grammar                        (debug) print term grammar
  -dot &lt;filename&gt;                    (debug) dot graph of syntax dependencies
  -alltt &lt;filename&gt;                  (debug) alltt output of single source file
  -sort &lt;true&gt;                       (debug) do topological sort
  -process_defns &lt;true&gt;              (debug) process inductive reln definitions
  -showraw &lt;false&gt;                   (debug) show raw grammar
  -ugly &lt;false&gt;                      (debug) use ugly ASCII output
  -no_rbcatn &lt;true&gt;                  (debug) remove relevant bind clauses
  -lem_debug                         (debug) print lem debug locations
  -help                              Display this list of options
  --help                             Display this list of options
</PRE><!--TOC section Reference: The language of symbolic terms-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc52">23</A>&#XA0;&#XA0;Reference: The language of symbolic terms</H2><!--SEC END --><P><A NAME="a17"></A>A syntax definition conceptually defines two different languages: that
of concrete terms of the object language, and that of symbolic terms
over the object language. 
The former includes concrete variables (if nontrivial <CODE>lex</CODE> homs
have been specified for metavariables). 
The latter includes the former but also
allows symbolic metavariables and nonterminals.
Symbolic terms may also include the production-name
annotations mentioned in &#XA7;<A HREF="#a51">3</A>.
For a syntax definition with list forms (c.f.&#XA0;&#XA7;<A HREF="#a61">12</A>) symbolic
terms also include various list constructs.
A simplified abstract syntax of symbolic terms is shown in
Figure&#XA0;<A HREF="#a19">17</A>, omitting list forms. In this section we give an
informal definition of the full concrete syntax of symbolic terms.
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<IMG SRC="top2037.gif"><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 17: Mini-Ott in Ott: symbolic terms<A NAME="a19"></A></TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The premises and conclusions of inductive definition rules are
symbolic terms. 
The language of symbolic terms is defined informally below, with interpretation functions [[_]] that map defined entities into grammar clauses.</P><P>For a rule <I><I>rule</I></I> &#XA0; = 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I><I>nontermroot</I></I><SUB>1</SUB>&#XA0;&#XA0;&#XA0;,&#XA0;&#XA0;&#XA0;..&#XA0;&#XA0;&#XA0;,&#XA0;&#XA0;&#XA0;<I><I>nontermroot</I></I><SUB><I>n</I></SUB>&#XA0;<TT>::</TT>&#XA0;&#XA0;&#XA0;<TT>&#X2019;&#X2019;</TT>&#XA0;&#XA0;&#XA0;<TT>::=</TT>&#XA0;&#XA0;&#XA0;<I><I>prod</I></I><SUB>1</SUB>&#XA0;&#XA0;&#XA0;..&#XA0;&#XA0;&#XA0;<I><I>prod</I></I><SUB><I><I>m</I></I></SUB>&#XA0;</TD></TR>
</TABLE><P>
we have
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>&#XA0;[[<I><I>rule</I></I>]]</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><I>nontermroot</I></I>&#XA0;<I>suffix</I></TD><TD ALIGN=left NOWRAP>(1)&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP>[[<I><I>prod</I></I><SUB>1</SUB>]]&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP>..&#XA0;&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP>[[<I><I>prod</I></I><SUB><I><I>m</I></I></SUB>]]&#XA0;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>(1) for each <I><I>nontermroot</I></I> in the set
{<I><I>nontermroot</I></I><SUB>1</SUB> &#XA0; , &#XA0; .. &#XA0; , &#XA0;
<I><I>nontermroot</I></I><SUB><I>n</I></SUB> } 
and for each <I><I>nontermroot</I></I> defined by any <I><I>rule</I></I>&#X2032;
which is declared as a subrule of this rule. </P><P>For a production  <I><I>prod</I></I> &#XA0; = 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TT>|</TT>&#XA0;&#XA0;&#XA0;<I><I>element</I></I><SUB>1</SUB>&#XA0;&#XA0;&#XA0;..&#XA0;&#XA0;&#XA0;<I><I>element</I></I><SUB><I><I>m</I></I></SUB>&#XA0;&#XA0;&#XA0;<TT>::</TT>&#XA0;&#XA0;&#XA0;<TT>::</TT>&#XA0;&#XA0;&#XA0;<I><I>prodname</I></I></TD></TR>
</TABLE><P>
we have
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>&#XA0;[[<I><I>prod</I></I>]]</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP>[[<I><I>element</I></I><SUB>1</SUB>]]&#XA0;&#XA0;&#XA0;..&#XA0;&#XA0;&#XA0;[[<I><I>element</I></I><SUB><I><I>m</I></I></SUB>]]&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>:</TT><I><I>prodname</I></I><TT>:</TT>&#XA0;&#XA0;[[<I><I>element</I></I><SUB>1</SUB>]]&#XA0;&#XA0;&#XA0;..&#XA0;&#XA0;&#XA0;[[<I><I>element</I></I><SUB><I><I>m</I></I></SUB>]]&#XA0;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>For an element there are various cases. 
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
For a terminal <I><I>terminal</I></I>
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>&#XA0;[[<I><I>terminal</I></I>]]</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><I>terminal</I></I></TD></TR>
</TABLE></TD></TR>
</TABLE>
</LI><LI CLASS="li-enumerate">For a nonterminal <I><I>nontermroot</I></I> &#XA0; <I><I>suffix</I></I>
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>&#XA0;[[<I><I>nontermroot</I></I>&#XA0;&#XA0;&#XA0;<I><I>suffix</I></I>]]</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>[[<I><I>rule</I></I>]]&#XA0;</TD></TR>
</TABLE></TD></TR>
</TABLE>
where <I><I>rule</I></I> includes <I><I>nontermroot</I></I> among the
nonterminal roots it defines. (Note that this does not depend on what <I><I>suffix</I></I> was used in the grammar, and similarly for the <I><I>metavar</I></I> case below.)</LI><LI CLASS="li-enumerate">For an index variable <I><I>indexvarroot</I></I>
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>&#XA0;[[<I><I>indexvarroot</I></I>]]</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><I>indexvarroot</I></I>&#X2032;</TD></TR>
</TABLE></TD></TR>
</TABLE>
for each <I><I>indexvarroot</I></I>&#X2032; defined by the <TT>indexvar</TT>
definition that defines <I><I>indexvarroot</I></I>.</LI><LI CLASS="li-enumerate">For a metavariable <I><I>metavarroot</I></I> &#XA0; <I><I>suffix</I></I>
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>&#XA0;[[<I><I>metavarroot</I></I>&#XA0;&#XA0;&#XA0;<I><I>suffix</I></I>]]</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><I>metavarroot</I></I>&#X2032;&#XA0;<I>suffix</I></TD><TD ALIGN=left NOWRAP>(1)&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><I>variable</I></I>&#XA0;</TD></TR>
</TABLE></TD></TR>
</TABLE>
(1) for each <I><I>metavarroot</I></I>&#X2032; defined by the <TT>metavar</TT>
definition that defines <I><I>metavarroot</I></I>.
(2) where <I><I>variable</I></I> ranges over all the strings defined by
the <TT>lex</TT> regexp of the <TT>metavar</TT>
definition that defines <I><I>metavarroot</I></I>, except for any string
which can be parsed as a nonterminal, metavariable or terminal of the syntax
definition.
</LI><LI CLASS="li-enumerate">A list form element <I><I>element</I></I> could be any of the following, either without a separating terminal:
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I><I>element</I></I><SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I><SUB><I>n</I></SUB>&#XA0;
&#XA0;&#XA0;<I><I>dots</I></I>&#XA0;&#XA0;
<I><I>element</I></I>&#X2032;<SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I>&#X2032;<SUB><I>n</I></SUB>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;<I><I>element</I></I><SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I><SUB><I>n</I></SUB>&#XA0;&#XA0;&#XA0;<TT>//</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;<I><I>element</I></I><SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I><SUB><I>n</I></SUB>&#XA0;&#XA0;&#XA0;<TT>//</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#XA0;&#XA0;&#XA0;<TT>IN</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2032;&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;<I><I>element</I></I><SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I><SUB><I>n</I></SUB>&#XA0;&#XA0;&#XA0;<TT>//</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#XA0;&#XA0;&#XA0;<TT>IN</TT>&#XA0;&#XA0;&#XA0;<I><I>number</I></I>&#XA0;&#XA0;&#XA0;<I><I>dots</I></I>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2032;&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;<I><I>element</I></I><SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I><SUB><I>n</I></SUB>&#XA0;&#XA0;&#XA0;<TT>//</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#XA0;&#XA0;&#XA0;<TT>IN</TT>&#XA0;&#XA0;&#XA0;<I><I>number</I></I>&#XA0;&#XA0;&#XA0;<I><I>dots</I></I>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2032;<TT>-1</TT>&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
</TABLE></TD></TR>
</TABLE>
or with a separating terminal:
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I><I>element</I></I><SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I><SUB><I>n</I></SUB>&#XA0;
&#XA0;&#XA0;<I><I>terminal</I></I>&#XA0;&#XA0;&#XA0;<I><I>dots</I></I>&#XA0;&#XA0;&#XA0;<I><I>terminal</I></I>&#XA0;&#XA0;
<I><I>element</I></I>&#X2032;<SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I>&#X2032;<SUB><I>n</I></SUB>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;<I><I>element</I></I><SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I><SUB><I>n</I></SUB>&#XA0;&#XA0;&#XA0;<TT>//</TT>&#XA0;&#XA0;<I><I>terminal</I></I>&#XA0;<TT>//</TT>&#XA0;&#XA0;<I><I>indexvar</I></I>&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;<I><I>element</I></I><SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I><SUB><I>n</I></SUB>&#XA0;&#XA0;&#XA0;<TT>//</TT>&#XA0;&#XA0;<I><I>terminal</I></I>&#XA0;<TT>//</TT>&#XA0;&#XA0;<I><I>indexvar</I></I>&#XA0;&#XA0;&#XA0;<TT>IN</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2032;&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;<I><I>element</I></I><SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I><SUB><I>n</I></SUB>&#XA0;&#XA0;&#XA0;<TT>//</TT>&#XA0;&#XA0;<I><I>terminal</I></I>&#XA0;<TT>//</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#XA0;&#XA0;&#XA0;<TT>IN</TT>&#XA0;&#XA0;&#XA0;<I><I>number</I></I>&#XA0;&#XA0;&#XA0;<I><I>dots</I></I>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2032;&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;<I><I>element</I></I><SUB>1</SUB>&#XA0;..&#XA0;<I><I>element</I></I><SUB><I>n</I></SUB>&#XA0;&#XA0;&#XA0;<TT>//</TT>&#XA0;&#XA0;<I><I>terminal</I></I>&#XA0;<TT>//</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#XA0;&#XA0;&#XA0;<TT>IN</TT>&#XA0;&#XA0;&#XA0;<I><I>number</I></I>&#XA0;&#XA0;&#XA0;<I><I>dots</I></I>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2032;<TT>-1</TT>&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
</TABLE></TD></TR>
</TABLE>
In any of these cases the interpretation [[<I><I>element</I></I>]] is the lists (separated by the <I><I>terminal</I></I> if one was specified) of concrete list entries and of list forms.
Without a separating <I><I>terminal</I></I>, this is: 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>&#XA0;[[<I><I>element</I></I>]]</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>(<I>concrete</I>_<I>list</I>_<I>entry</I>&#XA0;|&#XA0;<I>list</I>_<I>form</I>)<SUP>*</SUP></TD><TD ALIGN=left NOWRAP>(2),&#XA0;(3)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><I>concrete</I>_<I>list</I>_<I>entry</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>[[<I><I>element</I></I><SUB>1</SUB>]]&#XA0;&#XA0;&#XA0;..&#XA0;&#XA0;&#XA0;[[<I><I>element</I></I><SUB><I>n</I></SUB>]]&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><I>list</I>_<I>form</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP>[[<I><I>element</I></I><SUB>1</SUB>]]&#XA0;&#XA0;&#XA0;..&#XA0;&#XA0;&#XA0;[[<I><I>element</I></I><SUB><I>n</I></SUB>]]&#XA0;
&#XA0;<I><I>dots</I></I>&#X2032;&#XA0;
[[<I><I>element</I></I>&#X2032;<SUB>1</SUB>]]&#XA0;&#XA0;&#XA0;..&#XA0;&#XA0;&#XA0;[[<I><I>element</I></I>&#X2032;<SUB><I>n</I></SUB>]]</TD><TD ALIGN=left NOWRAP>(1)&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;[[<I><I>element</I></I><SUB>1</SUB>]]&#XA0;..&#XA0;[[<I><I>element</I></I><SUB><I>n</I></SUB>]]&#XA0;&#XA0;&#XA0;<TT>//</TT>&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2033;&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;[[<I><I>element</I></I><SUB>1</SUB>]]&#XA0;..&#XA0;[[<I><I>element</I></I><SUB><I>n</I></SUB>]]&#XA0;<TT>//</TT>&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2033;&#XA0;&#XA0;&#XA0;<TT>IN</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2034;&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;[[<I><I>element</I></I><SUB>1</SUB>]]&#XA0;..&#XA0;[[<I><I>element</I></I><SUB><I>n</I></SUB>]]&#XA0;<TT>//</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2033;&#XA0;&#XA0;&#XA0;<TT>IN</TT>&#XA0;&#XA0;&#XA0;<I><I>number</I></I>&#X2032;&#XA0;&#XA0;&#XA0;<I><I>dots</I></I>&#X2032;&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2034;&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>&lt;/</TT>&#XA0;&#XA0;[[<I><I>element</I></I><SUB>1</SUB>]]&#XA0;..&#XA0;[[<I><I>element</I></I><SUB><I>n</I></SUB>]]&#XA0;<TT>//</TT>&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2033;&#XA0;&#XA0;&#XA0;<TT>IN</TT>&#XA0;&#XA0;&#XA0;<I><I>number</I></I>&#X2032;&#XA0;&#XA0;&#XA0;<I><I>dots</I></I>&#X2032;&#XA0;&#XA0;&#XA0;<I><I>indexvar</I></I>&#X2034;<TT>-1</TT>&#XA0;&#XA0;&#XA0;<TT>/&gt;</TT>&#XA0;</TD></TR>
</TABLE></TD></TR>
</TABLE>
This is subject to constraints: (1) that 
[[<I><I>element</I></I><SUB>1</SUB>]] &#XA0; .. &#XA0; [[<I><I>element</I></I><SUB><I>n</I></SUB>]]
and
[[<I><I>element</I></I>&#X2032;<SUB>1</SUB>]] &#XA0; .. &#XA0; [[<I><I>element</I></I>&#X2032;<SUB><I>n</I></SUB>]] can be
anti-unified with exactly one varying index; (2) if the list has only
concrete entries (i.e., no list forms), its length must meet
the constraint of any <I>dots</I> in the
<I><I>element</I></I>.<P>With a separating <I><I>terminal</I></I>, we have: 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>&#XA0;[[<I><I>element</I></I>]]</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#X454;&#XA0;|&#XA0;(<I>concrete</I>_<I>list</I>_<I>entry</I>&#XA0;|&#XA0;<I>list</I>_<I>form</I>)
(<I><I>terminal</I></I>&#XA0;(<I>concrete</I>_<I>list</I>_<I>entry</I>&#XA0;|&#XA0;<I>list</I>_<I>form</I>))<SUP>*</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></LI></OL><P>In the above 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I>dots</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><TT>..</TT>&#XA0;|&#XA0;<TT>...</TT>&#XA0;|&#XA0;<TT>....</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><I>number</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><TT>0</TT>&#XA0;|&#XA0;<TT>1</TT>&#XA0;&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><I>suffix</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I>suffix</I>_<I>item</I><SUP>*</SUP>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP><I>suffix</I>_<I>item</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP>(<TT>0</TT>&#XA0;|&#XA0;<TT>1</TT>&#XA0;|<TT>2</TT>&#XA0;|&#XA0;<TT>3</TT>&#XA0;|<TT>4</TT>&#XA0;|&#XA0;<TT>5</TT>&#XA0;|<TT>6</TT>&#XA0;|&#XA0;<TT>7</TT>&#XA0;|<TT>8</TT>&#XA0;|&#XA0;<TT>9</TT>)<SUP>+</SUP></TD><TD ALIGN=left NOWRAP>(longest match)&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>_</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>&#X2019;</TT>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><I>indexvar</I></I>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><I>indexvar</I></I><TT>-1</TT>&#XA0;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Further, whitespace (<CODE>' '|'\010'|'\009'|'\013'|'\012'</CODE>) is allowed before any token except a those in a suffix, and nonterminals, metavariables, index variables, and terminals that end with an alphanumeric character, must not be followed by an alphanumeric character.</P><P>The tool also builds a parser
for concrete terms, with fake nonterminal roots <TT>concrete_ntr</TT>
for each primary <TT>ntr</TT> of the syntax definition. One can
switch to concrete-term parsing with a <TT>:concrete:</TT> annotation,
as in the example 
</P><PRE CLASS="verbatim">\[ [[ :concrete: \Z1&lt;:Top. \x:Z1.x ]]\]
</PRE><P>
shown in Figure&#XA0;<A HREF="#a56">10</A>. Below such an annotation, only concrete terms
are permitted, with no further annotation, no symbolic nonterminals or
metavariables, no list dot forms or comprehensions, etc.</P><P>Parsing of terms is done with a scannerless GLR parser over character-list
inputs. The parser
searches for all parses of the input. If none are found, the ASCII
and TeX output are annotated <TT>no parses</TT>, with a copy of the
input with <TT>***</TT> inserted at the point where the last token was
read. This is often at the point of the error (though if, for
example, a putative dot form is read but the two element lists cannot
be anti-unified, it will be after the point of the error). 
If multiple parses are found, the TeX output is annotated
<TT>multiple parses</TT> and the different parses are output to the
console in detail during the Ott run.</P><P>The GLR parser 
achieves reasonable performance on the small symbolic terms that are
typical in semantic rules. Its performance on large (whole-program
size) examples is untested.</P><!--TOC section Reference: Generation of proof assistant definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc53">24</A>&#XA0;&#XA0;Reference: Generation of proof assistant definitions</H2><!--SEC END --><P><A NAME="a42"></A>This section briefly summarises the steps involved in the generation
of proof assistant definitions from an Ott source file. For a description of the locally-nameless backend, refer to <A HREF="http://moscova.inria.fr/&#XA0;zappa/projects/ln_ott/"><TT>http://moscova.inria.fr/&#XA0;zappa/projects/ln_ott/</TT></A>.
</P><!--TOC subsection Generation of types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">24.1</A>&#XA0;&#XA0;Generation of types</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize"> 
The primary metavariable roots and primary nonterminal roots are used
directly as the names of proof assistant types, except where they
have a hom specifying a root-overriding string.
</LI><LI CLASS="li-itemize">Type abbreviation declarations are produced for metavars, in the
source-file order, skipping metavars or nonterminals defined with <FONT COLOR="#A51815"><TT>phantom</TT></FONT>.
</LI><LI CLASS="li-itemize">Type generation considers each rule of the user&#X2019;s source grammar
except those for <CODE>formula</CODE> and <CODE>terminals</CODE> (or the
synthesized rules for the syntax of judgements or <CODE>user_syntax</CODE>).
</LI><LI CLASS="li-itemize">The subrule order is analysed to identify the top elements. For
each of those, a proof assistant type will be generated &#X2014; either a
free type (<CODE>coq</CODE>: <CODE>inductive</CODE>, <CODE>isa</CODE>:
<CODE>datatype</CODE>, <CODE>hol</CODE>: <CODE>Hol_datatype</CODE>), or if there is a
type hom for the proof assistant in question, a type abbreviation.
No types are generated for the non-top elements, as they will be
represented as predicates over the top free type above them.
</LI><LI CLASS="li-itemize">For the former, each non-meta production of the rule
gives rise to a constructor. The production name (with any per-rule
prefix already applied) is used directly as the constructor name. 
The (curried) constructor argument types are taken from the
types associated with the metavariables and nonterminals mentioned
in the production body. 
</LI><LI CLASS="li-itemize">Rules (within each <FONT COLOR="#A51815"><TT>grammar</TT></FONT> block, if <TT>-merge
false</TT>, or all rules, if <TT>-merge true</TT>) are topologically sorted according to the dependency order
(a free-type rule directly depends on another if one of its non-meta
productions includes a nonterminal of the other; dependencies for rules with a type-hom
for the proof assistant in question
are obtained from a crude lexing of the body of the type hom).
We then generate mutually recursive type
definitions for connected components, in an order consistent with
the dependencies.
</LI><LI CLASS="li-itemize">For productions that involve list dot forms or list comprehension
forms, for HOL and Isabelle we produce constructors with argument
types that involve native list types. For Coq, however, we
synthesise an additional inductive type for each list-of-tuples that arises
(both for those that occur in the grammar and for others required in
the translations of inductive definitions) and include them in the
topological sort. 
</LI></UL><!--TOC subsection Generation of functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">24.2</A>&#XA0;&#XA0;Generation of functions</H3><!--SEC END --><P>
A small number of library functions (<CODE>list_mem</CODE>,
<CODE>list_minus</CODE>,...) are included in the output if they are
required.</P><P>Several Coq list functions (<CODE>map</CODE>, <CODE>make</CODE>, <CODE>unmake</CODE>, <CODE>nth</CODE>, <CODE>app</CODE>) are generated
for each synthesized list type.</P><P>The definitions of the more interesting functions (subrule predicates,
binding auxiliaries, free variable functions, and substitutions) are
generated over the free types generated for the maximal elements of the
subrule order (generation of these functions for rules with type homs
is not supported). The definitions are by pattern-matching and
recursion.
The patterns are generated by building canonical symbolic terms from
the productions of each relevant rule.
The recursion is essentially primitive recursion:
for Coq we produce <CODE>Fixpoint</CODE>s or <CODE>Definition</CODE>s
(the latter is sometimes needed as the former gives an error in the case where there is no
recursion);
for Isabelle we produce <CODE>primrec</CODE>s (or, experimentally, <CODE>fun</CODE>s);
for HOL we use an <CODE>ottDefine</CODE> variant of the <CODE>Define</CODE>
package.
In general we have to deal both with the type dependency 
(the topologically sorted mutually recursive types described above)
and with function dependency &#X2014; for example, for subrule predicates
and binding auxiliaries we may have multiple mutually recursive
functions over the same type.</P><P>For Coq the function generation over productions that involve list
types must mirror that, so we generate auxiliary functions 
that recurse over those list types. </P><P>For Isabelle the <CODE>primrec</CODE> package does not support 
definitions involving several mutually recursive functions over the
same type, so for these we generate single functions calculating 
tuples of results, define the intended functions as projections of
these, and generate lemmas (and simple proof scripts) characterising
them in terms of the intended definitions.
Further, it does not support pattern matching involving nested
constructors. We therefore generate auxiliary functions for
productions with embedded list types. Isabelle tuples are treated as
iterated pairs, so we do the same for productions with tuples of size
3 or more. 
Isabelle also requires a function definition for each recursive type.
In the case where there are multiple uses of the same type
(e.g.&#XA0;several uses of <CODE>t list</CODE> in different productions) all the
functions we wish to generate need identical auxiliaries. As yet, the
tool does not generate the identical copies required.</P><P>If the option <CODE>-isabelle_primrec</CODE> is set to <CODE>false</CODE>, then
Ott uses the <CODE>fun</CODE> package instead of the <CODE>primrec</CODE> package.
Since at the time of writing Isabelle 2008 is not capable of proving
automatically termination of all the <CODE>fun</CODE>s that Ott generates,
this feature should be considered experimental.</P><P>For HOL the standard <CODE>Define</CODE> package tries an automatic
termination proof. For productions that involve list types 
our generated functions involve various list functions which prevent
those proofs working in all cases. 
We therefore use an <CODE>ottDefine</CODE> variant (due to Scott Owens),
with slightly stronger support for proving termination of
definitions involving list operators.</P><!--TOC subsubsection Subrule predicates-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc56">24.2.1</A>&#XA0;&#XA0;Subrule predicates</H4><!--SEC END --><P><A NAME="a43"></A>We generate subrule predicates to carve out the subsets of each free
proof assistant type (from the maximal elements of the subrule order) 
that represent the rules of the grammar. 
The non-free rules are the least subset of the rules that either
(1) occur on the left of a subrule (<CODE>&lt;::</CODE>) declaration, or
(2) have a (non-meta) production that mentions a non-free rule. 
Note that these can include rules that are maximal elements of the
subrule order, e.g.&#XA0;if an expression grammar included a production
involving packaged values. 
The subrule predicate for a type is defined by pattern matching over
constructors of the maximal type above it &#X2014; for each non-meta
production of the maximal type it calculates a disjunction
over all the productions of the lower type that are subproductions of
it, invoking other subrule predicates as appropriate. </P><!--TOC subsubsection Binding auxiliaries-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc57">24.2.2</A>&#XA0;&#XA0;Binding auxiliaries</H4><!--SEC END --><P>
The binding auxiliary functions calculate the intuitive semantics of auxiliary functions defined in bindspecs of the Ott source file. Currently these are represented as proof assistant lists of metavariables or nonterminals (arguably set types should be used instead, at least in Isabelle).</P><!--TOC subsubsection Free variables-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc58">24.2.3</A>&#XA0;&#XA0;Free variables</H4><!--SEC END --><P>
The free variable functions simply walk over the structure of the free proof assistant types, using any bind specifications (and binding auxiliaries) as appropriate. 
For these, and for substitutions, we simplify the generated functions by using the dependency analysis of the syntax to exclude recursive calls where there is no dependency. </P><!--TOC subsubsection Substitutions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc59">24.2.4</A>&#XA0;&#XA0;Substitutions</H4><!--SEC END --><P>
The generated substitution functions also walk over the structure of the free proof assistant types. 
For each production, for each occurrence of a nonterminal <CODE>nt</CODE> within it, we first calculate the things (of whatever type is in question) binding in that <CODE>nt</CODE>, i.e.&#XA0;those that should be removed from the domain of any substitution pushed down into it. There are two cases:
(1) the <CODE>mse'</CODE> from any <CODE>bind mse' in nt</CODE>;
(2) <CODE>nt</CODE> itself if it occurs in the <CODE>mse''</CODE> of any <CODE>bind mse'' in nt''</CODE>, i.e.&#XA0;
<CODE>nt</CODE> itself if it is directly used to bind elsewhere.
List forms within bindspecs are dealt with analogously. 
</P><P>The substitution function clause for a production is then of one of two forms:
either (1) the production comprises a single element, of the nonterminal or metavariable that we are substituting for, and this is within the rule of the nonterminal that it is being replaced by, or (2) all other cases. 
For (1) the element is compared with the domain of the substitution, and replaced by the corresponding value from the range if it is found.
For (2) the substitution functions are mapped over the subelements, having first removed any bound things from the domain of the substitution. </P><P>This is all done similarly, but with differences in detail, for single and for multiple substitutions. </P><!--TOC subsection Generation of relations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc60">24.3</A>&#XA0;&#XA0;Generation of relations</H3><!--SEC END --><P>
The semantic relations are defined
with the proof-assistant inductive relations packages
(<CODE>coq</CODE>: <CODE>Inductive</CODE>,
<CODE>isa</CODE>: <CODE>inductive</CODE>,
<CODE>hol</CODE>: <CODE>Hol_reln</CODE>).
They use the mutual recursion structure that is given by the user,
with each <CODE>defns</CODE> block giving rise to a potentially mutually
recursive definition of each <CODE>defn</CODE> inside it.
(It is debatable whether it would be preferable to do an automatic dependency analysis and topological sort, as for the syntax.)
Each definition rule gives rise to an implicational clause, essentially
that the premises (Ott <CODE>formula</CODE>s) imply the conclusion (an Ott symbolic term of whichever judgement is being defined). 
In addition:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Symbolic terms are transformed in various different ways:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Nodes of non-meta productions are output as applications of the appropriate proof-assistant constructor (and, for a subrule, promoted to the corresponding constructor of a maximal rule).
</LI><LI CLASS="li-itemize">Nodes of meta productions are transformed with the user-specified homomorphism.
</LI><LI CLASS="li-itemize">Nodes of judgement forms are represented as applications of the defined relation in Coq and HOL, and as set-membership assertions in Isabelle.
</LI><LI CLASS="li-itemize">Lists of formulae (the <CODE>formula_dots</CODE> production) are special-cased.
</LI></UL>
</LI><LI CLASS="li-itemize">For each nonterminal of a non-free syntax rule (as in &#XA7;<A HREF="#a43">24.2.1</A>) that occurs,
e.g.&#XA0;a usage of <CODE>v'</CODE> where <CODE>v&lt;::t</CODE>, an additional premise invoking the subrule predicate for the non-free rule is added, e.g.&#XA0;<CODE>is_v v'</CODE>.
</LI><LI CLASS="li-itemize">The set of symbolic terms of the definition rule are analysed together to identify list forms with the same bounds. A single proof assistant variable is introduced for each such, with appropriate projections and list maps/foralls at the usage points.
</LI><LI CLASS="li-itemize">For Coq, auxiliary defined relations are introduced for list forms.
</LI><LI CLASS="li-itemize">For Coq, as the projections from list forms involve (Ott-generated) <CODE>nth</CODE> functions that return option types, for any such projection a pattern-match against <CODE>Some</CODE> is introduced as an additional premise.
</LI><LI CLASS="li-itemize">For Coq and HOL, explicit quantifiers are introduced for all variables mentioned in the rule.
</LI></UL><!--TOC section Reference: Summary of homomorphisms-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc61">25</A>&#XA0;&#XA0;Reference: Summary of homomorphisms</H2><!--SEC END --><P><A NAME="a41"></A>Homomorphisms can appear in various positions in an Ott source
file. The table below summarises their meanings. A * indicates that arguments are meaningful for that usage (e.g.&#XA0;<TT><FONT COLOR="#007FFF">[[</FONT></TT><TT>e1</TT><TT><FONT COLOR="#007FFF">]]</FONT></TT> in a production mentioning a nonterminal or metavariable
<CODE>e1</CODE>).</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3>a metavar or indexvar declaration, after one of the defined metavar/indexvar roots, or</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>a rule, after one of the defined nonterminal
roots</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>tex</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>LaTeX typesetting for symbolic variables with that root</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isa</TT></FONT>/<FONT COLOR="#A51815"><TT>coq</TT></FONT>/<FONT COLOR="#A51815"><TT>hol</TT></FONT>/<FONT COLOR="#A51815"><TT>ocaml</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Isabelle/Coq/HOL/OCaml root overriding string (1)</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>repr-locally-nameless</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>use a locally-nameless representation (Coq backend only)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
</TABLE><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3>a metavar or indexvar declaration, after the <TT>::=</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isa</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Isabelle representation type</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>coq</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Coq representation type</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>hol</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>HOL representation type</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ocaml</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>OCaml representation type</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>tex</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>LaTeX typesetting for symbolic variables</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>com</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>comment to appear in LaTeX syntax definition</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>coq-equality</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Coq proof script to decide equality over the representation type</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>repr-locally-nameless</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>(Coq only) use a locally-nameless representation</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>phantom</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>suppress the representation type definition in theorem prover output</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>lex</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>regular expression for lexing concrete variables</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>texvar</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>LaTeX typesetting for concrete variables</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isavar</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>Isabelle output for concrete variables</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>holvar</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>HOL output for concrete variables</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ocamlvar</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>OCaml output for concrete variables</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
</TABLE><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3>a rule, after the <FONT COLOR="#007FFF"><TT>::=</TT></FONT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isa</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Isabelle representation type, if a non-free type is required</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>coq</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Coq representation type, if a non-free type is required</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>hol</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>HOL representation type, if a non-free type is required</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ocaml</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>OCaml representation type, if a non-free type is required</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>tex</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>LaTeX typesetting for symbolic variables</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>com</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>comment to appear in LaTeX syntax definition</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>coq-equality</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Coq proof script to decide equality over the representation type</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>coq-universe</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Coq universe (e.g.&#XA0;<TT>Type</TT>) for the representation type</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>phantom</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>suppress the representation type definition in theorem prover output</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>aux</TT></FONT></TD><TD ALIGN=center NOWRAP>(*)</TD><TD ALIGN=left NOWRAP>construct an auxiliary grammar rule with a single production</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>icho</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>shorthand for identical <FONT COLOR="#A51815"><TT>coq</TT></FONT>, <FONT COLOR="#A51815"><TT>isa</TT></FONT>, <FONT COLOR="#A51815"><TT>hol</TT></FONT>, and <FONT COLOR="#A51815"><TT>ocaml</TT></FONT> homs</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ichlo</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>shorthand for identical <FONT COLOR="#A51815"><TT>coq</TT></FONT>,
<FONT COLOR="#A51815"><TT>isa</TT></FONT>, <FONT COLOR="#A51815"><TT>hol</TT></FONT>, <FONT COLOR="#A51815"><TT>lem</TT></FONT>, and <FONT COLOR="#A51815"><TT>ocaml</TT></FONT> homs</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ich</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>shorthand for identical <FONT COLOR="#A51815"><TT>coq</TT></FONT>, <FONT COLOR="#A51815"><TT>isa</TT></FONT> and <FONT COLOR="#A51815"><TT>hol</TT></FONT> homs</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ic</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>shorthand for identical <FONT COLOR="#A51815"><TT>coq</TT></FONT> and <FONT COLOR="#A51815"><TT>isa</TT></FONT> homs</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ch</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>shorthand for identical <FONT COLOR="#A51815"><TT>coq</TT></FONT> and <FONT COLOR="#A51815"><TT>hol</TT></FONT> homs</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ih</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>shorthand for identical <FONT COLOR="#A51815"><TT>isa</TT></FONT> and <FONT COLOR="#A51815"><TT>hol</TT></FONT> homs</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
</TABLE><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3>a production</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isa</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>Isabelle output, for a non-free (meta) production</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>coq</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>Coq output, for a non-free (meta) production</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>hol</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>HOL output, for a non-free (meta) production</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ocaml</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>OCaml output, for a non-free (meta) production</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>tex</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>LaTeX typesetting for symbolic terms</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>texlong</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>typeset as long production</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>com</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>comment to appear in LaTeX syntax definition</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>order</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>specify order of arguments to prover or Ocaml constructor</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isasyn</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>Isabelle mixfix syntax output</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isaprec</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Isabelle mixfix syntax precedence string</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ich</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>shorthand for identical <FONT COLOR="#A51815"><TT>coq</TT></FONT>, <FONT COLOR="#A51815"><TT>isa</TT></FONT> and <FONT COLOR="#A51815"><TT>hol</TT></FONT>homs</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ic</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>shorthand for identical <FONT COLOR="#A51815"><TT>coq</TT></FONT> and <FONT COLOR="#A51815"><TT>isa</TT></FONT> homs</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ch</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>shorthand for identical <FONT COLOR="#A51815"><TT>coq</TT></FONT> and <FONT COLOR="#A51815"><TT>hol</TT></FONT> homs</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ih</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>shorthand for identical <FONT COLOR="#A51815"><TT>isa</TT></FONT> and <FONT COLOR="#A51815"><TT>hol</TT></FONT> homs</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
</TABLE><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3>a production of the <TT>terminals</TT> grammar</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isa</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Isabelle output, for terminals in default generated Isabelle mixfix declarations</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>tex</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>LaTeX default typesetting for terms</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>com</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>comment to appear in LaTeX syntax definition</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
</TABLE><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3>a <FONT COLOR="#A51815"><TT>defn</TT></FONT>, before the <FONT COLOR="#A51815"><TT>by</TT></FONT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>tex</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>LaTeX typesetting for symbolic terms</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>com</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>comment to appear in LaTeX syntax definition</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isasyn</TT></FONT></TD><TD ALIGN=center NOWRAP>*</TD><TD ALIGN=left NOWRAP>Isabelle mixfix syntax output</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isaprec</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Isabelle mixfix syntax precedence string</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>lemwcf</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Lem witness, check, and functions spec for indrelns</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>a <FONT COLOR="#A51815"><TT>homs</TT></FONT> section clause (for a production or a definition)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>as in the above production and <FONT COLOR="#A51815"><TT>defn</TT></FONT> forms</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
</TABLE><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3>a group of defns, after the <FONT COLOR="#007FFF"><TT>::=</TT></FONT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>coq-universe</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Coq universe (e.g.&#XA0;<TT>Type</TT>) for the representation type</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
</TABLE><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3>an <FONT COLOR="#A51815"><TT>embed</TT></FONT> section</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isa</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>embedded Isabelle output</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>coq</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>embedded Coq output</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>hol</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>embedded HOL output</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>ocaml</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>embedded OCaml output</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>tex</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>embedded LaTeX output</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>tex-preamble</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>embedded LaTeX output, appearing in the LaTeX preamble</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>coq-lib</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>do not generate definitions for the listed helper functions</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isa-auxfn-proof</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Isabelle proof script</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isa-subrule-proof</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Isabelle proof script</TD></TR>
</TABLE><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3>in a subrule, substitution or function definition</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#A51815"><TT>isa-proof</TT></FONT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>Isabelle proof script</TD></TR>
</TABLE><P>(1) This is occasionally useful to work around a clash between a
metavar or nonterminal primary root and a proof assistant symbol,
e.g.&#XA0;<TT>value</TT> in Isabelle or <TT>T</TT> in HOL.</P><!--TOC section Reference: The Ott source grammar-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc62">26</A>&#XA0;&#XA0;Reference: The Ott source grammar</H2><!--SEC END --><P>
This is automatically generated (by <CODE>mly-y2l</CODE>) from the
<CODE>ocamlyacc</CODE> grammar for Ott.
</P><P>The lexing of Ott source files is context-dependent; this does not
show that.</P><P>Not everything in the grammar is fully supported &#X2014; in particular,
option element forms, non-dotted element list forms, the three <CODE>names</CODE> distinctness forms of
bindspecs, and context rules.</P><!--TOC section Reference: Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc63">27</A>&#XA0;&#XA0;Reference: Examples</H2><!--SEC END --><P><A NAME="a33"></A>The project web page
</P><BLOCKQUOTE CLASS="quotation">
<A HREF="http://www.cl.cam.ac.uk/users/pes20/ott/"><TT>http://www.cl.cam.ac.uk/users/pes20/ott/</TT></A>
</BLOCKQUOTE><P>
gives a variety of examples. Some of these, and additional
small examples, are included in the distribution in the <CODE>tests</CODE>
directory. Typically they can be built using the <CODE>Makefile</CODE> in
the <CODE>ott</CODE> directory, e.g.&#XA0;typing <CODE>make test10</CODE> or (more generally) <CODE>make tests/test10.out</CODE>) there.</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP> <CODE>test10.ott</CODE></TD><TD ALIGN=left NOWRAP>untyped CBV lambda</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>test10st.ott</CODE></TD><TD ALIGN=left NOWRAP>simply typed CBV lambda</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>test8.ott</CODE></TD><TD ALIGN=left NOWRAP>ML polymorphism example</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>test7a.ott</CODE></TD><TD ALIGN=left NOWRAP>POPLmark Fsub example (without records)</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>test7b.ott</CODE></TD><TD ALIGN=left NOWRAP>POPLmark Fsub example (with records)</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>leroy-jfp96.ott</CODE></TD><TD ALIGN=left NOWRAP>Leroy module system</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>lj.ott</CODE></TD><TD ALIGN=left NOWRAP>LJ: Lightweight Java</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>test7t.mng</CODE></TD><TD ALIGN=left NOWRAP>whole-document tex mng source</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>(<CODE>make test7afilter</CODE> to build)</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>test7tt.mng</CODE></TD><TD ALIGN=left NOWRAP>fragment tex mng source</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>test11.ott</CODE></TD><TD ALIGN=left NOWRAP>subrule example</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>test12.ott</CODE></TD><TD ALIGN=left NOWRAP>topological sort example</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>test13.ott</CODE></TD><TD ALIGN=left NOWRAP>small bindspec fragment</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>test10st_snapshot_out.thy</CODE></TD><TD ALIGN=left NOWRAP>snapshot of generated Isabelle from <CODE>test10st.ott</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>test10st_metatheory_autoed.thy</CODE></TD><TD ALIGN=left NOWRAP>Isabelle proof script for type
preservation and progress</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>test10st_codegen.thy</CODE></TD><TD ALIGN=left NOWRAP>Isabelle code generation script for reduction</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>test10_isasyn.ott</CODE></TD><TD ALIGN=left NOWRAP>Isabelle mixfix syntax example</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>test10st_metatheoryScript.sml</CODE></TD><TD ALIGN=left NOWRAP>HOL proof script for type preservation and progress</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>test17.10.ott</CODE></TD><TD ALIGN=left NOWRAP>list comprehension examples</TD></TR>
</TABLE><P>The <CODE>examples/tapl</CODE> directory contains several examples taken from the book &#X2018;Types and Programming Languages&#X2019; by Benjamin Pierce. The <TT>make</TT> targets, listed below, combine Ott source files
following roughly the TinkerType component structure used in TAPL.</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP> <CODE>sys-bool</CODE></TD><TD ALIGN=left NOWRAP>booleans (p34)</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>sys-arith</CODE></TD><TD ALIGN=left NOWRAP>arithmetic expressions (p41)</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>sys-untyped</CODE></TD><TD ALIGN=left NOWRAP>untyped lambda-calculus with booleans</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>sys-puresimple</CODE></TD><TD ALIGN=left NOWRAP>simply-typed lambda-calculus</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>sys-tybool</CODE></TD><TD ALIGN=left NOWRAP>typed booleans</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>sys-sortoffullsimple</CODE></TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>sys-roughlyfullsimple</CODE></TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>sys-puresub</CODE></TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>sys-purercdsub</CODE></TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
</TABLE><P>Other examples can be found on the locally-nameless backend web page.</P><!--TOC section Acknowledgements-->
<H2 CLASS="section"><!--SEC ANCHOR -->Acknowledgements</H2><!--SEC END --><P>
We thank 
the Ott users for their feedback, especially Matthew Parkinson;
the other members of the POPLmark team, especially Benjamin
Pierce, Stephanie Weirich, and Steve Zdancewic, for 
discussions;
and Keith Wansbrough, Matthew Fairbairn, and Tom Wilkie, for their work
on various Ott predecessors.</P><P>We acknowledge the support of EPSRC grants
GR/T11715, EP/C510712 and EP/F036345, a Royal Society
University Research Fellowship (Sewell), an EPSRC Leadership
Fellowship (Sewell), and ANR grant ANR-06-SETI-010-02 (Zappa Nardelli). </P><!--TOC section References-->
<H2 CLASS="section"><!--SEC ANCHOR -->References</H2><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="poplmark"><FONT COLOR=purple>[ABF</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>05]</FONT></A></DT><DD CLASS="dd-thebibliography">
Brian&#XA0;E. Aydemir, Aaron Bohannon, Matthew Fairbairn, J.&#XA0;Nathan Foster,
Benjamin&#XA0;C. Pierce, Peter Sewell, Dimitrios Vytiniotis, Geoffrey Washburn,
Stephanie Weirich, and Steve Zdancewic.
Mechanized metatheory for the masses: The POPLmark Challenge.
In <EM>Proc.&#XA0;TPHOLs, LNCS 3603</EM>, 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="FGLMR96"><FONT COLOR=purple>[FGL</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>96]</FONT></A></DT><DD CLASS="dd-thebibliography">
C&#XE9;dric Fournet, Georges Gonthier, Jean-Jacques L&#XE9;vy, Luc Maranget, and
Didier R&#XE9;my.
A calculus of mobile agents.
In <EM>Proc.&#XA0;CONCUR &#X2019;96, LNCS 1119</EM>, 1996.</DD><DT CLASS="dt-thebibliography"><A NAME="Leroy-generativity"><FONT COLOR=purple>[Ler96]</FONT></A></DT><DD CLASS="dd-thebibliography">
Xavier Leroy.
A syntactic theory of type generativity and sharing.
<EM>Journal of Functional Programming</EM>, 6(5):667&#X2013;698, 1996.</DD><DT CLASS="dt-thebibliography"><A NAME="LevinPierce99"><FONT COLOR=purple>[LP03]</FONT></A></DT><DD CLASS="dd-thebibliography">
Michael&#XA0;Y. Levin and Benjamin&#XA0;C. Pierce.
Tinkertype: A language for playing with formal systems.
<EM>Journal of Functional Programming</EM>, 13(2), March 2003.</DD><DT CLASS="dt-thebibliography"><A NAME="Pierce:TypeSystems"><FONT COLOR=purple>[Pie02]</FONT></A></DT><DD CLASS="dd-thebibliography">
Benjamin&#XA0;C. Pierce.
<EM>Types and Programming Languages</EM>.
MIT Press, 2002.</DD><DT CLASS="dt-thebibliography"><A NAME="ljam-sub"><FONT COLOR=purple>[SSP07]</FONT></A></DT><DD CLASS="dd-thebibliography">
Rok Strni&#X161;a, Peter Sewell, and Matthew Parkinson.
The Java Module System: core design and semantic definition.
In <EM>Proceedings of </EM><EM>OOPSLA</EM><EM> 2007, the </EM><EM>22nd ACM SIGPLAN
International Conference on Object-Oriented Programming, Systems, Languages
and Applications (Montre</EM><EM>&#XE1;</EM><EM>l)</EM>, October 2007.
15pp.</DD><DT CLASS="dt-thebibliography"><A NAME="ott-sub"><FONT COLOR=purple>[SZNO</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>07]</FONT></A></DT><DD CLASS="dd-thebibliography">
Peter Sewell, Francesco Zappa&#XA0;Nardelli, Scott Owens, Gilles Peskine, Thomas
Ridge, Susmit Sarkar, and Rok&#XA0;Strni&#X161;a.
Ott: Effective tool support for the working semanticist.
In <EM>Proceedings of ICFP 2007: </EM><EM>the 12th ACM SIGPLAN International
Conference on Functional Programming (Freiburg)</EM>, October 2007.
12pp.</DD><DT CLASS="dt-thebibliography"><A NAME="ott-jfp"><FONT COLOR=purple>[SZNO</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>10]</FONT></A></DT><DD CLASS="dd-thebibliography">
Peter Sewell, Francesco Zappa&#XA0;Nardelli, Scott Owens, Gilles Peskine, Thomas
Ridge, Susmit Sarkar, and Rok&#XA0;Strni&#X161;a.
Ott: Effective tool support for the working semanticist.
<EM>Journal of Functional Programming</EM>, 20(1):70&#X2013;122, January 2010.
Invited submission from ICFP 2007.</DD></DL><!--BEGIN NOTES document-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">Strictly, clauses
of primitive recursive function definitions from symbolic terms to strings, here of LaTeX code.
</DD></DL>
<!--END NOTES-->
<!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
